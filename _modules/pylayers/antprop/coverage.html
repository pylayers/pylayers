

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pylayers.antprop.coverage &mdash; PyLayers</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Python
          

          
            
            <img src="../../../_static/pylayers.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebook/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout1.html">Loading an outdoor layout from its address</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_antenna.html">Antenna Pattern for an H plane sectoral antenna &#64; 32GHz</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout2.html">Building graphs of a Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_coverage.html">Indoor Radio Coverage with Motley Keenan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_layout.html">8 Random Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_issue314.html">Exemple of issue 314</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exAbsGas.html">Attenuation due to atmospheric gases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exDLink.html">Evaluation of a radio link DLink</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_w1.html">Indoor Radio Coverage FP7 WHERE1 M1 setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLuebbers.html">UWB Ray tracing simulation  in outdoor scenario</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction_polar.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html">1&nbsp;&nbsp;&nbsp;pylayers.util.project Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.layout">2&nbsp;&nbsp;&nbsp;pylayers.gis.layout Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.selectl">3&nbsp;&nbsp;&nbsp;pylayers.gis.selectl Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.srtm">4&nbsp;&nbsp;&nbsp;pylayers.gis.srtm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.osmparser">5&nbsp;&nbsp;&nbsp;pylayers.gis.osmparser Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.ezone">6&nbsp;&nbsp;&nbsp;pylayers.gis.ezone Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antenna">7&nbsp;&nbsp;&nbsp;pylayers.antprop.antenna Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.aarray">8&nbsp;&nbsp;&nbsp;pylayers.antprop.aarray Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.spharm">9&nbsp;&nbsp;&nbsp;pylayers.antprop.spharm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antssh">10&nbsp;&nbsp;&nbsp;pylayers.antprop.antssh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antvsh">11&nbsp;&nbsp;&nbsp;pylayers.antprop.antvsh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.slab">12&nbsp;&nbsp;&nbsp;pylayers.antprop.slab Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.signature">13&nbsp;&nbsp;&nbsp;pylayers.antprop.signature Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.interactions">14&nbsp;&nbsp;&nbsp;pylayers.antprop.interactions Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffraction">15&nbsp;&nbsp;&nbsp;pylayers.antprop.diffraction Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffRT">16&nbsp;&nbsp;&nbsp;pylayers.antprop.diffRT Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.rays">17&nbsp;&nbsp;&nbsp;pylayers.antprop.rays Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.loss">18&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.channel">19&nbsp;&nbsp;&nbsp;pylayers.antprop.channel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id39">20&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coverage">21&nbsp;&nbsp;&nbsp;pylayers.antprop.coverage Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coeffModel">22&nbsp;&nbsp;&nbsp;pylayers.antprop.coeffModel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.link">23&nbsp;&nbsp;&nbsp;pylayers.simul.link Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit">24&nbsp;&nbsp;&nbsp;pylayers.simul.exploit Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit_simulnet">25&nbsp;&nbsp;&nbsp;pylayers.simul.exploit_simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simulnet">26&nbsp;&nbsp;&nbsp;pylayers.simul.simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simultraj">27&nbsp;&nbsp;&nbsp;pylayers.simul.simultraj Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.exploit.simnet">28&nbsp;&nbsp;&nbsp;pylayers.exploit.simnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesuwb">29&nbsp;&nbsp;&nbsp;pylayers.measures.mesuwb Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesmimo">30&nbsp;&nbsp;&nbsp;pylayers.measures.mesmimo Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.cormoran">31&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.vna.E5072A">32&nbsp;&nbsp;&nbsp;pylayers.measures.vna.E5072A Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.parker.smparker">33&nbsp;&nbsp;&nbsp;pylayers.measures.parker.smparker Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.bsignal">34&nbsp;&nbsp;&nbsp;pylayers.signal.bsignal Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.standard">35&nbsp;&nbsp;&nbsp;pylayers.signal.standard Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.device">36&nbsp;&nbsp;&nbsp;pylayers.signal.device Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.DF">37&nbsp;&nbsp;&nbsp;pylayers.signal.DF Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.waveform">38&nbsp;&nbsp;&nbsp;pylayers.signal.waveform Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.agent">39&nbsp;&nbsp;&nbsp;pylayers.mobility.agent Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.ban.body">40&nbsp;&nbsp;&nbsp;pylayers.mobility.ban.body Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id138">41&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pylayers.antprop.coverage</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pylayers.antprop.coverage</h1><div class="highlight"><pre>
<span></span>&quot;&quot;&quot;
.. currentmodule:: pylayers.antprop.coverage

.. autosummary::
   :members:

&quot;&quot;&quot;
from pylayers.util.project import *
#from pylayers.measures.mesuwb import *
from pylayers.simul.radionode import *
import pylayers.util.pyutil as pyu
from pylayers.util.utilnet import str2bool
from pylayers.gis.layout import Layout
import pylayers.antprop.loss as loss
import pylayers.gis.ezone as ez
import pylayers.signal.standard as std

import matplotlib.cm  as cm
import sys
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as m
from mpl_toolkits.axes_grid1 import make_axes_locatable

if sys.version_info.major==2:
    import ConfigParser
else:
    import configparser as ConfigParser

import pdb
import doctest
from itertools import product

try:
    from mayavi import mlab
    from tvtk.tools import visual
except:
    print(&#39;mayavi not installed&#39;)


<div class="viewcode-block" id="Coverage"><a class="viewcode-back" href="../../../api/pylayers.antprop.coverage.Coverage.html#pylayers.antprop.coverage.Coverage">[docs]</a>class Coverage(PyLayers):
    &quot;&quot;&quot; Handle Layout Coverage

        Methods
        -------

        creategrid()
            create a uniform grid for evaluating losses
        cover()
            run the coverage calculation
        showPower()
            display the map of received power
        showLoss()
            display the map of losses


        Attributes
        ----------

        All attributes are read from fileini ino the ini directory of the
        current project

        _fileini
            default coverage.ini

        L     : a Layout
        nx    : number of point on x
        ny    : number of point on y
        tx    : transmitter position
        txpe  : transmitter power emmission level
        show  : boolean for automatic display power map
        na : number of access point

    &quot;&quot;&quot;


    def __init__(self,_fileini=&#39;coverage.ini&#39;):
        &quot;&quot;&quot; object constructor

        Parameters
        ----------

        _fileini : string
            name of the configuration file

        Notes
        -----

        Coverage is described in an ini file.
        Default file is coverage.ini and is placed in the ini directory of the current project.

        &quot;&quot;&quot;


        self.config = ConfigParser.ConfigParser(allow_no_value=True)
        self.config.read(pyu.getlong(_fileini,pstruc[&#39;DIRSIMUL&#39;]))

        self.layoutopt = dict(self.config.items(&#39;layout&#39;))
        self.gridopt   = dict(self.config.items(&#39;grid&#39;))
        self.apopt     = dict(self.config.items(&#39;ap&#39;))
        self.rxopt     = dict(self.config.items(&#39;rx&#39;))
        self.showopt   = dict(self.config.items(&#39;show&#39;))

        # get the Layout
        filename = self.layoutopt[&#39;filename&#39;]
        if filename.endswith(&#39;lay&#39;):
            self.typ = &#39;indoor&#39;
            self.L = Layout(filename)

            # get the receiving grid
            self.nx = eval(self.gridopt[&#39;nx&#39;])
            self.ny = eval(self.gridopt[&#39;ny&#39;])
            if &#39;zgrid&#39; in self.gridopt:
                self.zgrid = eval(self.gridopt[&#39;zgrid&#39;])
            else:
                self.zgrid = 1.0
            self.mode = self.gridopt[&#39;mode&#39;]
            assert self.mode in [&#39;file&#39;,&#39;full&#39;,&#39;zone&#39;], &quot;Error reading grid mode &quot;
            self.boundary = eval(self.gridopt[&#39;boundary&#39;])
            self.filespa = self.gridopt[&#39;file&#39;]
            #
            # create grid
            #
            self.creategrid(mode=self.mode,boundary=self.boundary,_fileini=self.filespa)

            self.dap = {}
            for k in self.apopt:
                kwargs  = eval(self.apopt[k])
                ap = std.AP(**kwargs)
                self.dap[eval(k)] = ap
            try:
                self.L.Gt.nodes()
            except:
                pass
            try:
                self.L.dumpr()
            except:
                self.L.build()
                self.L.dumpw()

        else:
            self.typ=&#39;outdoor&#39;
            self.E = ez.Ezone(filename)
            self.E.loadh5()
            self.E.rebase()

        # The frequency is fixed from the AP nature
        self.fGHz = np.array([])
        #self.fGHz = eval(self.txopt[&#39;fghz&#39;])
        #self.tx = np.array((eval(self.txopt[&#39;x&#39;]),eval(self.txopt[&#39;y&#39;])))
        #self.ptdbm = eval(self.txopt[&#39;ptdbm&#39;])
        #self.framelengthbytes = eval(self.txopt[&#39;framelengthbytes&#39;])

        # receiver section
        #self.rxsens = eval(self.rxopt[&#39;sensitivity&#39;])

        self.temperaturek  = eval(self.rxopt[&#39;temperaturek&#39;])
        self.noisefactordb = eval(self.rxopt[&#39;noisefactordb&#39;])

        # show section
        self.bshow = str2bool(self.showopt[&#39;show&#39;])

    def __repr__(self):
        st=&#39;&#39;
        if self.typ==&#39;indoor&#39;:
            st = st+ &#39;Layout file : &#39;+self.L._filename + &#39;\n\n&#39;
            st = st + &#39;-----list of Access Points ------&#39;+&#39;\n&#39;
            for k in self.dap:
                st = st + self.dap[k].__repr__()+&#39;\n&#39;
            st = st + &#39;-----Rx------&#39;+&#39;\n&#39;
            st= st+ &#39;temperature (K) : &#39;+ str(self.temperaturek) + &#39;\n&#39;
            st= st+ &#39;noisefactor (dB) : &#39;+ str(self.noisefactordb) + &#39;\n\n&#39;
            st = st + &#39;--- Grid ----&#39;+&#39;\n&#39;
            st= st+ &#39;mode : &#39; + str(self.mode) + &#39;\n&#39;
            if self.mode!=&#39;file&#39;:
                st= st+ &#39;nx : &#39; + str(self.nx) + &#39;\n&#39;
                st= st+ &#39;ny : &#39; + str(self.ny) + &#39;\n&#39;
            if self.mode==&#39;zone&#39;:
                st= st+ &#39;boundary (xmin,ymin,xmax,ymax) : &#39; + str(self.boundary) + &#39;\n\n&#39;
            if self.mode==&#39;file&#39;:
                st = st+&#39; filename : &#39;+self.filespa+&#39;\n&#39;
        return(st)

<div class="viewcode-block" id="Coverage.creategrid"><a class="viewcode-back" href="../../../api/pylayers.antprop.coverage.Coverage.html#pylayers.antprop.coverage.Coverage.creategrid">[docs]</a>    def creategrid(self,mode=&#39;full&#39;,boundary=[],_fileini=&#39;&#39;):
        &quot;&quot;&quot; create a grid

        Parameters
        ----------

        full : boolean
            default (True) use all the layout area
        boundary : (xmin,ymin,xmax,ymax)
            if full is False the boundary argument is used

        &quot;&quot;&quot;

        if mode==&quot;file&quot;:
            self.RN = RadioNode(name=&#39;&#39;,
                               typ=&#39;rx&#39;,
                               _fileini = _fileini,
                               _fileant = &#39;def.vsh3&#39;)
            self.grid =self.RN.position[0:2,:].T
        else:
            if mode==&quot;full&quot;:
                mi=np.min(np.array(list(self.L.Gs.pos.values())),axis=0)+0.01
                ma=np.max(np.array(list(self.L.Gs.pos.values())),axis=0)-0.01
            if mode==&quot;zone&quot;:
                assert boundary!=[]
                mi = np.array([boundary[0],boundary[1]])
                ma = np.array([boundary[2],boundary[3]])

            x = np.linspace(mi[0],ma[0],self.nx)
            y = np.linspace(mi[1],ma[1],self.ny)

            self.grid=np.array((list(np.broadcast(*np.ix_(x, y)))))

        self.ng = self.grid.shape[0]</div>

<div class="viewcode-block" id="Coverage.where1"><a class="viewcode-back" href="../../../api/pylayers.antprop.coverage.Coverage.html#pylayers.antprop.coverage.Coverage.where1">[docs]</a>    def where1(self):
        &quot;&quot;&quot;
        Unfinished : Not sure this is the right place (too specific)
        &quot;&quot;&quot;
        M1 = UWBMeasure(1)
        self.dap={}
        self.dap[1]={}
        self.dap[2]={}
        self.dap[3]={}
        self.dap[4]={}
        self.dap[1][&#39;p&#39;]=M1.rx[1,0:2]
        self.dap[2][&#39;p&#39;]=M1.rx[1,0:2]
        self.dap[3][&#39;p&#39;]=M1.rx[1,0:2]
        self.dap[4][&#39;p&#39;]=M1.rx[1,0:2]
        for k in range(300):
            try:
                M = UWBMeasure(k)
                tx = M.tx
                self.grid=np.vstack((self.grid,tx[0:2]))
                D  = M.rx-tx[np.newaxis,:]
                D2 = D*D
                dist = np.sqrt(np.sum(D2,axis=1))[1:]
                Emax = M.Emax()
                Etot = M.Etot()[0]
                try:
                    td1 = np.hstack((td1,dist[0]))
                    td2 = np.hstack((td2,dist[1]))
                    td3 = np.hstack((td3,dist[2]))
                    td4 = np.hstack((td4,dist[3]))
                    te1 = np.hstack((te1,Emax[0]))
                    te2 = np.hstack((te2,Emax[1]))
                    te3 = np.hstack((te3,Emax[2]))
                    te4 = np.hstack((te4,Emax[3]))
                    tt1 = np.hstack((tt1,Etot[0]))
                    tt2 = np.hstack((tt2,Etot[1]))
                    tt3 = np.hstack((tt3,Etot[2]))
                    tt4 = np.hstack((tt4,Etot[3]))
                    #tdist = np.hstack((tdist,dist))
                    #te = np.hstack((te,Emax))
                except:
                    td1=np.array(dist[0])
                    td2=np.array(dist[1])
                    td3=np.array(dist[2])
                    td4=np.array(dist[3])
                    te1 =np.array(Emax[0])
                    te2 =np.array(Emax[1])
                    te3 =np.array(Emax[2])
                    te4 =np.array(Emax[3])
                    tt1 =np.array(Etot[0])
                    tt2 =np.array(Etot[1])
                    tt3 =np.array(Etot[2])
                    tt4 =np.array(Etot[3])
            except:
                pass</div>

<div class="viewcode-block" id="Coverage.cover"><a class="viewcode-back" href="../../../api/pylayers.antprop.coverage.Coverage.html#pylayers.antprop.coverage.Coverage.cover">[docs]</a>    def cover(self,sinr=True,snr=True,best=True):
        &quot;&quot;&quot; run the coverage calculation

        Parameters
        ----------

        sinr : boolean
        snr  : boolean
        best : boolean

        Examples
        --------

        .. plot::
            :include-source:

            &gt;&gt;&gt; from pylayers.antprop.coverage import *
            &gt;&gt;&gt; C = Coverage()
            &gt;&gt;&gt; C.cover()
            &gt;&gt;&gt; f,a=C.show(typ=&#39;sinr&#39;,figsize=(10,8))
            &gt;&gt;&gt; plt.show()

        Notes
        -----

        self.fGHz is an array, it means that Coverage is calculated at once
        for a whole set of frequencies. In practice, it would be the center
        frequency of a given standard channel.

        This function is calling `loss.Losst` which calculates Losses along a
        straight path.

        In a future implementation we will
        abstract the EM solver in order to make use of other calculation
        approaches as a full or partial Ray Tracing.

        The following members variables are evaluated :

        + freespace Loss @ fGHz   PL()  PathLoss (shoud be rename FS as free space) $
        + prdbmo : Received power in dBm .. math:`P_{rdBm} =P_{tdBm} - L_{odB}`
        + prdbmp : Received power in dBm .. math:`P_{rdBm} =P_{tdBm} - L_{pdB}`
        + snro : SNR polar o (H)
        + snrp : SNR polar p (H)

        See Also
        --------

        pylayers.antprop.loss.Losst
        pylayers.antprop.loss.PL

        &quot;&quot;&quot;
        #
        # select active AP
        #
        lactiveAP = []
        try:
            del self.aap
            del self.ptdbm
        except:
            pass

    
        self.kB = 1.3806503e-23 # Boltzmann constant
        #
        # Loop opver access points
        #
        for iap in self.dap:
            if self.dap[iap][&#39;on&#39;]:
                lactiveAP.append(iap)
                fGHz = self.dap[iap].s.fcghz
                # The frequency band is set here
                self.fGHz=np.unique(np.hstack((self.fGHz,fGHz)))
                apchan = self.dap[iap][&#39;chan&#39;]
                try:
                    self.aap   = np.vstack((self.aap,self.dap[iap][&#39;p&#39;]))
                    self.ptdbm = np.vstack((self.ptdbm,self.dap[iap][&#39;PtdBm&#39;]))
                    self.bmhz  = np.vstack((self.bmhz,
                                 self.dap[iap].s.chan[apchan[0]][&#39;BMHz&#39;]))
                except:
                    self.aap   = self.dap[iap][&#39;p&#39;]
                    self.ptdbm = np.array(self.dap[iap][&#39;PtdBm&#39;])
                    self.bmhz  = np.array(self.dap[iap].s.chan[apchan[0]][&#39;BMHz&#39;])

        PnW = np.array((10**(self.noisefactordb/10.))*self.kB*self.temperaturek*self.bmhz*1e6)
        # Evaluate Noise Power (in dBm)
        self.pndbm = np.array(10*np.log10(PnW)+30)

        #lchan = map(lambda x: self.dap[x][&#39;chan&#39;],lap)
        #apchan = zip(self.dap.keys(),lchan)
        #self.bmhz = np.array(map(lambda x: self.dap[x[0]].s.chan[x[1][0]][&#39;BMHz&#39;]*len(x[1]),apchan))

        self.ptdbm = self.ptdbm.T
        self.pndbm = self.pndbm.T
        # creating all links
        # all grid to all ap 
        #
        if len(self.pndbm.shape ) == 0:
            self.ptdbm = self.ptdbm.reshape(1,1)
            self.pndbm = self.pndbm.reshape(1,1)

        p = product(range(self.ng),lactiveAP)
        #
        # pa : access point
        # pg : grid point
        #
        # 1 x na

        for k in p:
            pg = self.grid[k[0],:]
            pa = np.array(self.dap[k[1]][&#39;p&#39;])
            # exemple with 3 AP
            # 321 0
            # 321 1
            # 321 2
            # 322 0
            try:
                self.pa = np.vstack((self.pa,pa))
            except:
                self.pa = pa
            try:
                self.pg = np.vstack((self.pg,pg))
            except:
                self.pg = pg

        self.pa = self.pa.T
        shpa = self.pa.shape
        shpg = self.pg.shape

        if shpa[0] != 3:
            self.pa = np.vstack((self.pa,np.ones(shpa[1])))
        self.pg = self.pg.T
        self.pg = np.vstack((self.pg,self.zgrid*np.ones(shpg[0])))

        self.nf = len(self.fGHz)

        # retrieving dimensions along the 3 axis
        na = len(lactiveAP)
        self.na = na
        ng = self.ng
        nf = self.nf

        for k,iap in enumerate(self.dap):
            # select only one access point
            u = na*np.arange(0,ng,1).astype(&#39;int&#39;)+k
            if self.dap[iap][&#39;on&#39;]:
                pt = self.pa[:,u]
                pr = self.pg[:,u]
                azoffset = self.dap[iap][&#39;phideg&#39;]*np.pi/180.
                self.dap[iap].A.eval(fGHz=self.fGHz, pt=pt, pr=pr, azoffset=azoffset)

                gain = (self.dap[iap].A.G).T
                #pdb.set_trace()
                # to handle omnidirectional antenna (nf,1,1)
                if gain.shape[1]==1:
                    gain = np.repeat(gain,ng,axis=1)
                try:
                    tgain = np.dstack((tgain,gain[:,:,None]))
                except:
                    tgain = gain[:,:,None]

        #Lwo,Lwp,Edo,Edp = loss.Losst(self.L,self.fGHz,self.pa,self.pg,dB=False)
        Lwo,Lwp,Edo,Edp = loss.Losst(self.L,self.fGHz,self.pa,self.pg,dB=False)

        self.Lwo = Lwo.reshape(nf,ng,na)
        self.Edo = Edo.reshape(nf,ng,na)
        self.Lwp = Lwp.reshape(nf,ng,na)
        self.Edp = Edp.reshape(nf,ng,na)

        freespace = loss.PL(self.fGHz,self.pa,self.pg,dB=False)
        self.freespace = freespace.reshape(nf,ng,na)

        # transmitting power
        # f x g x a

        # CmW : Received Power coverage in mW
        self.CmWo = 10**(self.ptdbm[np.newaxis,...]/10.)*self.Lwo*self.freespace*tgain
        self.CmWp = 10**(self.ptdbm[np.newaxis,...]/10.)*self.Lwp*self.freespace*tgain


        if snr:
            self.evsnr()
        if sinr:
            self.evsinr()
        if best:
            self.evbestsv()</div>

<div class="viewcode-block" id="Coverage.evsnr"><a class="viewcode-back" href="../../../api/pylayers.antprop.coverage.Coverage.html#pylayers.antprop.coverage.Coverage.evsnr">[docs]</a>    def evsnr(self):
        &quot;&quot;&quot; calculates signal to noise ratio
        &quot;&quot;&quot;

        NmW = 10**(self.pndbm/10.)[np.newaxis,:]

        self.snro = self.CmWo/NmW
        self.snrp = self.CmWp/NmW</div>

<div class="viewcode-block" id="Coverage.evsinr"><a class="viewcode-back" href="../../../api/pylayers.antprop.coverage.Coverage.html#pylayers.antprop.coverage.Coverage.evsinr">[docs]</a>    def evsinr(self):
        &quot;&quot;&quot; calculates sinr

        &quot;&quot;&quot;

        # na : number of access point
        na = self.na

        # U : 1 x 1 x na x na
        U = (np.ones((na,na))-np.eye(na))[np.newaxis,np.newaxis,:,:]

        # CmWo : received power in mW orthogonal polarization
        # CmWp : received power in mW parallel polarization

        ImWo = np.einsum(&#39;ijkl,ijl-&gt;ijk&#39;,U,self.CmWo)
        ImWp = np.einsum(&#39;ijkl,ijl-&gt;ijk&#39;,U,self.CmWp)


        NmW = 10**(self.pndbm/10.)[np.newaxis,:]

        self.sinro = self.CmWo/(ImWo+NmW)
        self.sinrp = self.CmWp/(ImWp+NmW)</div>

<div class="viewcode-block" id="Coverage.evbestsv"><a class="viewcode-back" href="../../../api/pylayers.antprop.coverage.Coverage.html#pylayers.antprop.coverage.Coverage.evbestsv">[docs]</a>    def evbestsv(self):
        &quot;&quot;&quot; determine the best server map

        Notes
        -----

        C.bestsv

        &quot;&quot;&quot;
        na = self.na
        ng = self.ng
        nf = self.nf
        # find best server regions
        Vo = self.CmWo
        Vp = self.CmWp
        self.bestsvo = np.empty(nf*ng*na).reshape(nf,ng,na)
        self.bestsvp = np.empty(nf*ng*na).reshape(nf,ng,na)
        for kf in range(nf):
            MaxVo = np.max(Vo[kf,:,:],axis=1)
            MaxVp = np.max(Vp[kf,:,:],axis=1)
            for ka in range(na):
                uo = np.where(Vo[kf,:,ka]==MaxVo)
                up = np.where(Vp[kf,:,ka]==MaxVp)
                self.bestsvo[kf,uo,ka]=ka+1
                self.bestsvp[kf,up,ka]=ka+1</div>


#    def showEd(self,polar=&#39;o&#39;,**kwargs):
#        &quot;&quot;&quot; shows a map of direct path excess delay
#
#        Parameters
#        ----------
#
#        polar : string
#        &#39;o&#39; | &#39;p&#39;
#
#        Examples
#        --------
#
#        .. plot::
#            :include-source:
#
#            &gt;&gt; from pylayers.antprop.coverage import *
#            &gt;&gt; C = Coverage()
#            &gt;&gt; C.cover()
#            &gt;&gt; C.showEd(polar=&#39;o&#39;)
#
#        &quot;&quot;&quot;
#
#        if not kwargs.has_key(&#39;alphacy&#39;):
#            kwargs[&#39;alphacy&#39;]=0.0
#        if not kwargs.has_key(&#39;colorcy&#39;):
#            kwargs[&#39;colorcy&#39;]=&#39;w&#39;
#        if not kwargs.has_key(&#39;nodes&#39;):
#            kwargs[&#39;nodes&#39;]=False
#
#        fig,ax = self.L.showG(&#39;s&#39;,**kwargs)
#        l = self.grid[0,0]
#        r = self.grid[-1,0]
#        b = self.grid[0,1]
#        t = self.grid[-1,-1]
#
#        cdict = {
#        &#39;red&#39;  :  ((0., 0.5, 0.5), (1., 1., 1.)),
#        &#39;green&#39;:  ((0., 0.5, 0.5), (1., 1., 1.)),
#        &#39;blue&#39; :  ((0., 0.5, 0.5), (1., 1., 1.))
#        }
#        #generate the colormap with 1024 interpolated values
#        my_cmap = m.colors.LinearSegmentedColormap(&#39;my_colormap&#39;, cdict, 1024)
#
#        if polar==&#39;o&#39;:
#            prdbm=self.prdbmo
#        if polar==&#39;p&#39;:
#            prdbm=self.prdbmp
#
#
#
#        if polar==&#39;o&#39;:
#            mcEdof = np.ma.masked_where(prdbm &lt; self.rxsens,self.Edo)
#
#            cov=ax.imshow(mcEdof.reshape((self.nx,self.ny)).T,
#                             extent=(l,r,b,t),cmap = &#39;jet&#39;,
#                             origin=&#39;lower&#39;)
#
#
#
#            # cov=ax.imshow(self.Edo.reshape((self.nx,self.ny)).T,
#            #           extent=(l,r,b,t),
#            #           origin=&#39;lower&#39;)
#            titre = &quot;Map of LOS excess delay, polar orthogonal&quot;
#
#        if polar==&#39;p&#39;:
#            mcEdpf = np.ma.masked_where(prdbm &lt; self.rxsens,self.Edp)
#
#            cov=ax.imshow(mcEdpf.reshape((self.nx,self.ny)).T,
#                             extent=(l,r,b,t),cmap = &#39;jet&#39;,
#                             origin=&#39;lower&#39;)
#
#            # cov=ax.imshow(self.Edp.reshape((self.nx,self.ny)).T,
#            #           extent=(l,r,b,t),
#            #           origin=&#39;lower&#39;)
#            titre = &quot;Map of LOS excess delay, polar parallel&quot;
#
#        ax.scatter(self.tx[0],self.tx[1],linewidth=0)
#        ax.set_title(titre)
#
#        divider = make_axes_locatable(ax)
#        cax = divider.append_axes(&quot;right&quot;, size=&quot;5%&quot;, pad=0.05)
#        clb = fig.colorbar(cov,cax)
#        clb.set_label(&#39;excess delay (ns)&#39;)
#
#        if self.show:
#            plt.show()
#        return fig,ax
#
#    def showPower(self,rxsens=True,nfl=True,polar=&#39;o&#39;,**kwargs):
#        &quot;&quot;&quot; show the map of received power
#
#        Parameters
#        ----------
#
#        rxsens : bool
#              clip the map with rx sensitivity set in self.rxsens
#        nfl : bool
#              clip the map with noise floor set in self.pndbm
#        polar : string
#            &#39;o&#39;|&#39;p&#39;
#
#        Examples
#        --------
#
#        .. plot::
#            :include-source:
#
#            &gt; from pylayers.antprop.coverage import *
#            &gt; C = Coverage()
#            &gt; C.cover()
#            &gt; C.showPower()
#
#        &quot;&quot;&quot;
#
#        if not kwargs.has_key(&#39;alphacy&#39;):
#            kwargs[&#39;alphacy&#39;]=0.0
#        if not kwargs.has_key(&#39;colorcy&#39;):
#            kwargs[&#39;colorcy&#39;]=&#39;w&#39;
#        if not kwargs.has_key(&#39;nodes&#39;):
#            kwargs[&#39;nodes&#39;]=False
#        fig,ax = self.L.showG(&#39;s&#39;,**kwargs)
#
#        l = self.grid[0,0]
#        r = self.grid[-1,0]
#        b = self.grid[0,1]
#        t = self.grid[-1,-1]
#
#        if polar==&#39;o&#39;:
#            prdbm=self.prdbmo
#        if polar==&#39;p&#39;:
#            prdbm=self.prdbmp
#
##        tCM = plt.cm.get_cmap(&#39;jet&#39;)
##        tCM._init()
##        alphas = np.abs(np.linspace(.0,1.0, tCM.N))
##        tCM._lut[:-3,-1] = alphas
#
#        title=&#39;Map of received power - Pt = &#39; + str(self.ptdbm) + &#39; dBm&#39;+str(&#39; fGHz =&#39;) + str(self.fGHz) + &#39; polar = &#39;+polar
#
#        cdict = {
#        &#39;red&#39;  :  ((0., 0.5, 0.5), (1., 1., 1.)),
#        &#39;green&#39;:  ((0., 0.5, 0.5), (1., 1., 1.)),
#        &#39;blue&#39; :  ((0., 0.5, 0.5), (1., 1., 1.))
#        }
#
#        if not kwargs.has_key(&#39;cmap&#39;):
#        # generate the colormap with 1024 interpolated values
#            cmap = m.colors.LinearSegmentedColormap(&#39;my_colormap&#39;, cdict, 1024)
#        else:
#            cmap = kwargs[&#39;cmap&#39;]
#        #my_cmap = cm.copper
#
#
#        if rxsens :
#
#            ## values between the rx sensitivity and noise floor
#            mcPrf = np.ma.masked_where((prdbm &gt; self.rxsens)
#                                     &amp; (prdbm &lt; self.pndbm),prdbm)
#            # mcPrf = np.ma.masked_where((prdbm &gt; self.rxsens) ,prdbm)
#
#            cov1 = ax.imshow(mcPrf.reshape((self.nx,self.ny)).T,
#                             extent=(l,r,b,t),cmap = cm.copper,
#                             vmin=self.rxsens,origin=&#39;lower&#39;)
#
#            ### values above the sensitivity
#            mcPrs = np.ma.masked_where(prdbm &lt; self.rxsens,prdbm)
#            cov = ax.imshow(mcPrs.reshape((self.nx,self.ny)).T,
#                            extent=(l,r,b,t),
#                            cmap = cmap,
#                            vmin=self.rxsens,origin=&#39;lower&#39;)
#            title=title + &#39;\n black : Pr (dBm) &lt; %.2f&#39; % self.rxsens + &#39; dBm&#39;
#
#        else :
#            cov=ax.imshow(prdbm.reshape((self.nx,self.ny)).T,
#                          extent=(l,r,b,t),
#                          cmap = cmap,
#                          vmin=self.pndbm,origin=&#39;lower&#39;)
#
#        if nfl:
#            ### values under the noise floor
#            ### we first clip the value below the noise floor
#            cl = np.nonzero(prdbm&lt;=self.pndbm)
#            cPr = prdbm
#            cPr[cl] = self.pndbm
#            mcPruf = np.ma.masked_where(cPr &gt; self.pndbm,cPr)
#            cov2 = ax.imshow(mcPruf.reshape((self.nx,self.ny)).T,
#                             extent=(l,r,b,t),cmap = &#39;binary&#39;,
#                             vmax=self.pndbm,origin=&#39;lower&#39;)
#            title=title + &#39;\n white : Pr (dBm) &lt; %.2f&#39; % self.pndbm + &#39; dBm&#39;
#
#
#        ax.scatter(self.tx[0],self.tx[1],s=10,c=&#39;k&#39;,linewidth=0)
#
#        ax.set_title(title)
#        divider = make_axes_locatable(ax)
#        cax = divider.append_axes(&quot;right&quot;, size=&quot;5%&quot;, pad=0.05)
#        clb = fig.colorbar(cov,cax)
#        clb.set_label(&#39;Power (dBm)&#39;)
#
#        if self.show:
#            plt.show()
#
#        return fig,ax
#
#
#    def showTransistionRegion(self,polar=&#39;o&#39;):
#        &quot;&quot;&quot;
#
#        Notes
#        -----
#
#        See  : &quot;Analyzing the Transitional Region in Low Power Wireless Links&quot;
#                Marco Zuniga and Bhaskar Krishnamachari
#
#        Examples
#        --------
#
#        .. plot::
#            :include-source:
#
#            &gt; from pylayers.antprop.coverage import *
#            &gt; C = Coverage()
#            &gt; C.cover()
#            &gt; C.showTransitionRegion()
#
#        &quot;&quot;&quot;
#
#        frameLength = self.framelengthbytes
#
#        PndBm = self.pndbm
#        gammaU = 10*np.log10(-1.28*np.log(2*(1-0.9**(1./(8*frameLength)))))
#        gammaL = 10*np.log10(-1.28*np.log(2*(1-0.1**(1./(8*frameLength)))))
#
#        PrU = PndBm + gammaU
#        PrL = PndBm + gammaL
#
#        fig,ax = self.L.showGs()
#
#        l = self.grid[0,0]
#        r = self.grid[-1,0]
#        b = self.grid[0,1]
#        t = self.grid[-1,-1]
#
#        if polar==&#39;o&#39;:
#            prdbm=self.prdbmo
#        if polar==&#39;p&#39;:
#            prdbm=self.prdbmp
#
#        zones = np.zeros(np.shape(prdbm))
#        #pdb.set_trace()
#
#        uconnected  = np.nonzero(prdbm&gt;PrU)
#        utransition = np.nonzero((prdbm &lt; PrU)&amp;(prdbm &gt; PrL))
#        udisconnected = np.nonzero(prdbm &lt; PrL)
#
#        zones[uconnected] = 1
#        zones[utransition] = (prdbm[utransition]-PrL)/(PrU-PrL)
#        cov = ax.imshow(zones.reshape((self.nx,self.ny)).T,
#                             extent=(l,r,b,t),cmap = &#39;BuGn&#39;,origin=&#39;lower&#39;)
#
#        title=&#39;PDR region&#39;
#        ax.scatter(self.tx[0],self.tx[1],linewidth=0)
#
#        ax.set_title(title)
#        divider = make_axes_locatable(ax)
#        cax = divider.append_axes(&quot;right&quot;, size=&quot;5%&quot;, pad=0.05)
#        fig.colorbar(cov,cax)
#        if self.show:
#            plt.show()
#
<div class="viewcode-block" id="Coverage.plot"><a class="viewcode-back" href="../../../api/pylayers.antprop.coverage.Coverage.html#pylayers.antprop.coverage.Coverage.plot">[docs]</a>    def plot(self,**kwargs):
        &quot;&quot;&quot;
        &quot;&quot;&quot;
        defaults = { &#39;typ&#39;: &#39;pr&#39;,
                     &#39;grid&#39;: False,
                     &#39;f&#39; : 0,
                     &#39;a&#39; : 0,
                     &#39;db&#39;:True,
                     &#39;label&#39;:&#39;&#39;,
                     &#39;pol&#39;:&#39;p&#39;,
                     &#39;col&#39;:&#39;b&#39;
                   }
        for k in defaults:
            if k not in kwargs:
                kwargs[k]=defaults[k]

        if &#39;fig&#39; in kwargs:
            fig=kwargs[&#39;fig&#39;]
        else:
            fig=plt.figure()

        if &#39;ax&#39; in kwargs:
            ax = kwargs[&#39;ax&#39;]
        else:
            ax = fig.add_subplot(111)

        if kwargs[&#39;typ&#39;]==&#39;pr&#39;:
            if kwargs[&#39;a&#39;]!=-1:
                if kwargs[&#39;pol&#39;]==&#39;p&#39;:
                    U = self.CmWp[kwargs[&#39;f&#39;],:,kwargs[&#39;a&#39;]]
                if kwargs[&#39;pol&#39;]==&#39;o&#39;:
                    U = self.CmWo[kwargs[&#39;f&#39;],:,kwargs[&#39;a&#39;]]
            else:
                if kwargs[&#39;pol&#39;]==&#39;p&#39;:
                    U = self.CmWp[kwargs[&#39;f&#39;],:,:].reshape(self.na*self.ng)
                else:
                    U = self.CmWo[kwargs[&#39;f&#39;],:,:].reshape(self.na*self.ng)
            if kwargs[&#39;db&#39;]:
                U = 10*np.log10(U)

        D = np.sqrt(np.sum((self.pa-self.pg)*(self.pa-self.pg),axis=0))
        if kwargs[&#39;a&#39;]!=-1:
            D = D.reshape(self.ng,self.na)
            ax.semilogx(D[:,kwargs[&#39;a&#39;]],U,&#39;.&#39;,color=kwargs[&#39;col&#39;],label=kwargs[&#39;label&#39;])
        else:
            ax.semilogx(D,U,&#39;.&#39;,color=kwargs[&#39;col&#39;],label=kwargs[&#39;label&#39;])

        return fig,ax</div>

<div class="viewcode-block" id="Coverage.show"><a class="viewcode-back" href="../../../api/pylayers.antprop.coverage.Coverage.html#pylayers.antprop.coverage.Coverage.show">[docs]</a>    def show(self,**kwargs):
        &quot;&quot;&quot; show coverage

        Parameters
        ----------

        typ : string
            &#39;pr&#39; | &#39;sinr&#39; | &#39;capacity&#39; | &#39;loss&#39; | &#39;best&#39; | &#39;egd&#39;
        grid : boolean
        polar : string
            &#39;o&#39; | &#39;p&#39;
        best : boolean
            draw best server contour if True
        f : int
            frequency index
        a : int
            access point index (-1 all access point)

        Examples
        --------

        .. plot::
            :include-source:

            &gt;&gt;&gt; from pylayers.antprop.coverage import *
            &gt;&gt;&gt; C = Coverage()
            &gt;&gt;&gt; C.cover()
            &gt;&gt;&gt; f,a = C.show(typ=&#39;pr&#39;,figsize=(10,8))
            &gt;&gt;&gt; plt.show()
            &gt;&gt;&gt; f,a = C.show(typ=&#39;best&#39;,figsize=(10,8))
            &gt;&gt;&gt; plt.show()
            &gt;&gt;&gt; f,a = C.show(typ=&#39;loss&#39;,figsize=(10,8))
            &gt;&gt;&gt; plt.show()
            &gt;&gt;&gt; f,a = C.show(typ=&#39;sinr&#39;,figsize=(10,8))
            &gt;&gt;&gt; plt.show()

        See Also
        --------

        pylayers.gis.layout.Layout.showG

        &quot;&quot;&quot;
        defaults = { &#39;typ&#39;: &#39;pr&#39;,
                     &#39;grid&#39;: False,
                     &#39;polar&#39;:&#39;p&#39;,
                     &#39;f&#39; : 0,
                     &#39;a&#39; :-1,
                     &#39;db&#39;:True,
                     &#39;cmap&#39; :cm.jet,
                     &#39;best&#39;:True
                   }

        title = self.dap[list(self.dap.keys())[0]].s.name+ &#39; : &#39;

        for k in defaults:
            if k not in kwargs:
                kwargs[k]=defaults[k]
        polar = kwargs[&#39;polar&#39;]
        assert polar in [&#39;p&#39;,&#39;o&#39;],&quot;polar wrongly defined in show coverage&quot;

        if &#39;fig&#39; in kwargs:
            if &#39;ax&#39; in kwargs:
                fig,ax=self.L.showG(&#39;s&#39;,fig=kwargs[&#39;fig&#39;],ax=kwargs[&#39;ax&#39;])
            else:
                fig,ax=self.L.showG(&#39;s&#39;,fig=kwargs[&#39;fig&#39;])
        else:
            if &#39;figsize&#39; in kwargs:
                fig,ax=self.L.showG(&#39;s&#39;,figsize=kwargs[&#39;figsize&#39;])
            else:
                fig,ax=self.L.showG(&#39;s&#39;)

        # plot the grid
        if kwargs[&#39;grid&#39;]:
            for k in self.dap:
                p = self.dap[k].p
                ax.plot(p[0],p[1],&#39;or&#39;)

        f = kwargs[&#39;f&#39;]
        a = kwargs[&#39;a&#39;]
        typ = kwargs[&#39;typ&#39;]
        assert typ in [&#39;best&#39;,&#39;egd&#39;,&#39;sinr&#39;,&#39;snr&#39;,&#39;capacity&#39;,&#39;pr&#39;,&#39;loss&#39;],&quot;typ unknown in show coverage&quot;
        best = kwargs[&#39;best&#39;]

        dB = kwargs[&#39;db&#39;]

        # setting the grid

        l = self.grid[0,0]
        r = self.grid[-1,0]
        b = self.grid[0,1]
        t = self.grid[-1,-1]

        if typ==&#39;best&#39;:
            title = title + &#39;Best server&#39;+&#39; fc = &#39;+str(self.fGHz[f])+&#39; GHz&#39;+ &#39; polar : &#39;+polar
            for ka in range(self.na):
                if polar==&#39;p&#39;:
                    bestsv =  self.bestsvp[f,:,ka]
                if polar==&#39;o&#39;:    
                    bestsv =  self.bestsvo[f,:,ka]
                m = np.ma.masked_where(bestsv == 0,bestsv)
                if self.mode!=&#39;file&#39;:
                    W = m.reshape(self.nx,self.ny).T
                    ax.imshow(W, extent=(l,r,b,t),
                            origin=&#39;lower&#39;,
                            vmin=1,
                            vmax=self.na+1)
                else:
                    ax.scatter(self.grid[:,0],self.grid[:,1],c=m,s=20,linewidth=0)
            ax.set_title(title)
        else:
            if typ==&#39;egd&#39;:
                title = title + &#39;excess group delay : &#39;+&#39; fc = &#39;+str(self.fGHz[f])+&#39; GHz&#39;+ &#39; polar : &#39;+polar
                V = self.Ed
                dB = False
                legcb =  &#39;Delay (ns)&#39;
            if typ==&#39;sinr&#39;:
                title = title + &#39;SINR : &#39;+&#39; fc = &#39;+str(self.fGHz[f])+&#39; GHz&#39;+ &#39; polar : &#39;+polar
                if dB:
                    legcb = &#39;dB&#39;
                else:
                    legcb = &#39;Linear scale&#39;
                if polar==&#39;o&#39;:        
                    V = self.sinro
                if polar==&#39;p&#39;:    
                    V = self.sinrp
            if typ==&#39;snr&#39;:
                title = title + &#39;SNR : &#39;+&#39; fc = &#39;+str(self.fGHz[f])+&#39; GHz&#39;+ &#39; polar : &#39;+polar
                if dB:
                    legcb = &#39;dB&#39;
                else:
                    legcb = &#39;Linear scale&#39;
                if polar==&#39;o&#39;:
                    V = self.snro
                if polar==&#39;p&#39;:
                    V = self.snrp
            if typ==&#39;capacity&#39;:
                title = title + &#39;Capacity : &#39;+&#39; fc = &#39;+str(self.fGHz[f])+&#39; GHz&#39;+ &#39; polar : &#39;+polar
                legcb = &#39;Mbit/s&#39;
                if polar==&#39;o&#39;:
                    V = self.bmhz.T[np.newaxis,:]*np.log(1+self.sinro)/np.log(2)
                if polar==&#39;p&#39;:
                    V = self.bmhz.T[np.newaxis,:]*np.log(1+self.sinrp)/np.log(2)
            if typ==&#39;pr&#39;:
                title = title + &#39;Pr : &#39;+&#39; fc = &#39;+str(self.fGHz[f])+&#39; GHz&#39;+ &#39; polar : &#39;+polar
                if dB:
                    legcb = &#39;dBm&#39;
                else:
                    lgdcb = &#39;mW&#39;
                if polar==&#39;o&#39;:
                    V = self.CmWo
                if polar==&#39;p&#39;:
                    V = self.CmWp

            if typ==&#39;loss&#39;:
                title = title + &#39;Loss : &#39;+&#39; fc = &#39;+str(self.fGHz[f])+&#39; GHz&#39;+ &#39; polar : &#39;+polar
                if dB:
                    legcb = &#39;dB&#39;
                else:
                    legcb = &#39;Linear scale&#39;
                if polar==&#39;o&#39;:
                    V = self.Lwo*self.freespace
                if polar==&#39;p&#39;:
                    V = self.Lwp*self.freespace

            if a == -1:
                V = np.max(V[f,:,:],axis=1)
            else:
                V = V[f,:,a]

            # reshaping the data on the grid
            if self.mode!=&#39;file&#39;:
                U = V.reshape((self.nx,self.ny)).T
            else:
                U = V

            if dB:
                U = 10*np.log10(U)

            if &#39;vmin&#39; in kwargs:
                vmin = kwargs[&#39;vmin&#39;]
            else:
                vmin = U.min()

            if &#39;vmax&#39; in kwargs:
                vmax = kwargs[&#39;vmax&#39;]
            else:
                vmax = U.max()

            if self.mode!=&#39;file&#39;:
                img = ax.imshow(U,
                            extent=(l,r,b,t),
                            origin=&#39;lower&#39;,
                            vmin = vmin,
                            vmax = vmax,
                            cmap = kwargs[&#39;cmap&#39;])
            else:
                img=ax.scatter(self.grid[:,0],
                               self.grid[:,1],
                               c=U,
                               s=20,
                               linewidth=0,
                               cmap=kwargs[&#39;cmap&#39;],
                               vmin=vmin,
                               vmax=vmax)

            for k in range(self.na):
                ax.annotate(str(k),xy=(self.pa[0,k],self.pa[1,k]))
            ax.set_title(title)

            divider = make_axes_locatable(ax)
            cax = divider.append_axes(&quot;right&quot;, size=&quot;5%&quot;, pad=0.05)
            clb = fig.colorbar(img,cax)
            clb.set_label(legcb)
            if best:
                if self.mode!=&#39;file&#39;:
                    if polar==&#39;o&#39;:
                        ax.contour(np.sum(self.bestsvo,axis=2)[f,:].reshape(self.nx,self.ny).T,extent=(l,r,b,t),linestyles=&#39;dotted&#39;)
                    if polar==&#39;p&#39;:
                        ax.contour(np.sum(self.bestsvp,axis=2)[f,:].reshape(self.nx,self.ny).T,extent=(l,r,b,t),linestyles=&#39;dotted&#39;)

        # display access points
        if a==-1:
            ax.scatter(self.pa[0,:],self.pa[1,:],s=30,c=&#39;r&#39;,linewidth=0)
        else:
            ax.scatter(self.pa[0,a],self.pa[1,a],s=30,c=&#39;r&#39;,linewidth=0)
        plt.tight_layout()
        return(fig,ax)</div></div>

#    def showLoss(self,polar=&#39;o&#39;,**kwargs):
#        &quot;&quot;&quot; show losses map
#
#        Parameters
#        ----------
#
#        polar : string
#            &#39;o&#39;|&#39;p&#39;|&#39;both&#39;
#
#        Examples
#        --------
#
#        .. plot::
#            :include-source:
#
#            &gt;&gt;&gt; from pylayers.antprop.coverage import *
#            &gt;&gt;&gt; C = Coverage()
#            &gt;&gt;&gt; C.cover(polar=&#39;o&#39;)
#            &gt;&gt;&gt; f,a = C.show(typ=&#39;pr&#39;,figsize=(10,8))
#            &gt;&gt;&gt; plt.show()
#        &quot;&quot;&quot;
#
#        fig = plt.figure()
#        fig,ax=self.L.showGs(fig=fig)
#
#        # setting the grid
#
#        l = self.grid[0,0]
#        r = self.grid[-1,0]
#        b = self.grid[0,1]
#        t = self.grid[-1,-1]
#
#        Lo = self.freespace+self.Lwo
#        Lp = self.freespace+self.Lwp
#
#        # orthogonal polarization
#
#        if polar==&#39;o&#39;:
#            cov = ax.imshow(Lo.reshape((self.nx,self.ny)).T,
#                            extent=(l,r,b,t),
#                            origin=&#39;lower&#39;,
#                            vmin = 40,
#                            vmax = 130)
#            str1 = &#39;Map of losses, orthogonal (V) polarization, fGHz=&#39;+str(self.fGHz)
#            title = (str1)
#
#        # parallel polarization
#        if polar==&#39;p&#39;:
#            cov = ax.imshow(Lp.reshape((self.nx,self.ny)).T,
#                            extent=(l,r,b,t),
#                            origin=&#39;lower&#39;,
#                            vmin = 40,
#                            vmax = 130)
#            str2 = &#39;Map of losses, orthogonal (V) polarization, fGHz=&#39;+str(self.fGHz)
#            title = (str2)
#
#        ax.scatter(self.tx[0],self.tx[1],s=10,c=&#39;k&#39;,linewidth=0)
#        ax.set_title(title)
#
#        divider = make_axes_locatable(ax)
#        cax = divider.append_axes(&quot;right&quot;, size=&quot;5%&quot;, pad=0.05)
#        clb = fig.colorbar(cov,cax)
#        clb.set_label(&#39;Loss (dB)&#39;)
#
#        if self.show:
#            plt.show()



if (__name__ == &quot;__main__&quot;):
    doctest.testmod()

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, PyLayers developer team.
      Last updated on Oct 17, 2018.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>