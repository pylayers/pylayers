

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pylayers.antprop.loss &mdash; PyLayers</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Python
          

          
            
            <img src="../../../_static/pylayers.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebook/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout1.html">Loading an outdoor layout from its address</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_antenna.html">Antenna Pattern for an H plane sectoral antenna &#64; 32GHz</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout2.html">Building graphs of a Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_coverage.html">Indoor Radio Coverage with Motley Keenan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_layout.html">8 Random Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_issue314.html">Exemple of issue 314</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exAbsGas.html">Attenuation due to atmospheric gases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exDLink.html">Evaluation of a radio link DLink</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_w1.html">Indoor Radio Coverage FP7 WHERE1 M1 setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLuebbers.html">UWB Ray tracing simulation  in outdoor scenario</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction_polar.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html">1&nbsp;&nbsp;&nbsp;pylayers.util.project Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.layout">2&nbsp;&nbsp;&nbsp;pylayers.gis.layout Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.selectl">3&nbsp;&nbsp;&nbsp;pylayers.gis.selectl Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.srtm">4&nbsp;&nbsp;&nbsp;pylayers.gis.srtm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.osmparser">5&nbsp;&nbsp;&nbsp;pylayers.gis.osmparser Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.ezone">6&nbsp;&nbsp;&nbsp;pylayers.gis.ezone Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antenna">7&nbsp;&nbsp;&nbsp;pylayers.antprop.antenna Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.aarray">8&nbsp;&nbsp;&nbsp;pylayers.antprop.aarray Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.spharm">9&nbsp;&nbsp;&nbsp;pylayers.antprop.spharm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antssh">10&nbsp;&nbsp;&nbsp;pylayers.antprop.antssh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antvsh">11&nbsp;&nbsp;&nbsp;pylayers.antprop.antvsh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.slab">12&nbsp;&nbsp;&nbsp;pylayers.antprop.slab Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.signature">13&nbsp;&nbsp;&nbsp;pylayers.antprop.signature Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.interactions">14&nbsp;&nbsp;&nbsp;pylayers.antprop.interactions Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffraction">15&nbsp;&nbsp;&nbsp;pylayers.antprop.diffraction Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffRT">16&nbsp;&nbsp;&nbsp;pylayers.antprop.diffRT Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.rays">17&nbsp;&nbsp;&nbsp;pylayers.antprop.rays Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.loss">18&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.channel">19&nbsp;&nbsp;&nbsp;pylayers.antprop.channel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id39">20&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coverage">21&nbsp;&nbsp;&nbsp;pylayers.antprop.coverage Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coeffModel">22&nbsp;&nbsp;&nbsp;pylayers.antprop.coeffModel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.link">23&nbsp;&nbsp;&nbsp;pylayers.simul.link Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit">24&nbsp;&nbsp;&nbsp;pylayers.simul.exploit Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit_simulnet">25&nbsp;&nbsp;&nbsp;pylayers.simul.exploit_simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simulnet">26&nbsp;&nbsp;&nbsp;pylayers.simul.simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simultraj">27&nbsp;&nbsp;&nbsp;pylayers.simul.simultraj Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.exploit.simnet">28&nbsp;&nbsp;&nbsp;pylayers.exploit.simnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesuwb">29&nbsp;&nbsp;&nbsp;pylayers.measures.mesuwb Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesmimo">30&nbsp;&nbsp;&nbsp;pylayers.measures.mesmimo Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.cormoran">31&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.vna.E5072A">32&nbsp;&nbsp;&nbsp;pylayers.measures.vna.E5072A Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.parker.smparker">33&nbsp;&nbsp;&nbsp;pylayers.measures.parker.smparker Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.bsignal">34&nbsp;&nbsp;&nbsp;pylayers.signal.bsignal Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.standard">35&nbsp;&nbsp;&nbsp;pylayers.signal.standard Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.device">36&nbsp;&nbsp;&nbsp;pylayers.signal.device Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.DF">37&nbsp;&nbsp;&nbsp;pylayers.signal.DF Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.waveform">38&nbsp;&nbsp;&nbsp;pylayers.signal.waveform Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.agent">39&nbsp;&nbsp;&nbsp;pylayers.mobility.agent Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.ban.body">40&nbsp;&nbsp;&nbsp;pylayers.mobility.ban.body Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id138">41&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pylayers.antprop.loss</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pylayers.antprop.loss</h1><div class="highlight"><pre>
<span></span># -*- coding:Utf-8 -*-
#from numpy import *
from __future__ import print_function
&quot;&quot;&quot;
.. currentmodule:: pylayers.antprop.loss

.. autosummary::
    :members:

&quot;&quot;&quot;
import doctest
import os
import glob
import doctest
import logging
import numpy as np
from scipy import io
import matplotlib.pylab as plt
import pylayers.gis.gisutil as gu
import numpy.linalg as la
import pdb
import time
from numba import jit

<div class="viewcode-block" id="PL0"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.PL0.html#pylayers.antprop.loss.PL0">[docs]</a>def PL0(fGHz,GtdB=0,GrdB=0,R=1):
    &quot;&quot;&quot;  Path Loss at frequency fGHZ @ R

    Parameters
    ----------

    fGHz: float
          frequency GHz
    GtdB: float
          transmitting antenna gain dB (default 0 dB)
    GrdB: float
          receiving antenna gain dB (default 0 dB)
    R   : float
        distance in m


    Returns
    -------

    PL0 : float
          path @ R

    Notes
    -----

    .. math:: PL_0 = -20 log_{10}(\\frac{\\lambda}{4\\pi}) - GtdB -GrdB

    Examples
    --------

    &gt;&gt;&gt; fGHz  = 2.4
    &gt;&gt;&gt; PL = PL0(fGHz)
    &gt;&gt;&gt; assert (PL&lt;41)&amp;(PL&gt;40),&quot;something wrong&quot;

    &quot;&quot;&quot;

    if not isinstance(fGHz,np.ndarray):
        fGHz=np.array([fGHz])

    ld  = 0.3/fGHz
    PL0 = -20*np.log10(ld/(4.0*np.pi*R))-GtdB-GrdB

    return PL0</div>

<div class="viewcode-block" id="Dgrid_points"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.Dgrid_points.html#pylayers.antprop.loss.Dgrid_points">[docs]</a>def Dgrid_points(points,Px):
    &quot;&quot;&quot; distance point to grid

    Parameters
    ----------

    points : np.array
             grid Np x 2 array

    Px     : np.array
             point 2 x 1  array

    Returns
    -------

    D: Euclidian distance matrix

    &quot;&quot;&quot;

    Dx = points[:,0] - Px[0]
    Dy = points[:,1] - Px[1]

    D = np.sqrt( Dx*Dx + Dy*Dy )

    return(D)</div>


<div class="viewcode-block" id="FMetisShad2"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.FMetisShad2.html#pylayers.antprop.loss.FMetisShad2">[docs]</a>def FMetisShad2(fGHz,r,D,sign=1):
    &quot;&quot;&quot; F Metis shadowing function

    Parameters
    ----------

    fGHz : np.array(Nf)
        frequency GHz
    r : np.array(Nseg,)
        distance between Tx and Rx
    D : np.array(Nseg,Nscreen)
        indirect distance between Tx and Rx (screen effect)
    sign : np.array(Nseg,Nscreen)
        == 1  : Shadowing NLOS situation
        ==-1  : No shadowing LOS situation   


    Returns
    -------

    F : np.array(Nseg,Nscreen,Nf)

    Notes
    -----

    Provides an implementation of formula (6.6) in D1.4 of METIS project


    See Also
    --------

    LossMetisShadowing


    &quot;&quot;&quot;
    lamda = 0.3/fGHz[None,None,:]
    F = np.arctan(sign[:,:,None]*np.pi/2.*(np.sqrt((np.pi/lamda)*(D[:,:,None]-r[:,None,None])))) / np.pi
    return(F)</div>

<div class="viewcode-block" id="FMetisShad"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.FMetisShad.html#pylayers.antprop.loss.FMetisShad">[docs]</a>def FMetisShad(fGHz,r,D,sign=1):
    &quot;&quot;&quot; F Metis shadowing function

    Parameters
    ----------

    fGHz : float 
        frequency GHz
    r : float
        distance between Tx and Rx
    D : float 
        indirect distance between Tx and Rx (screen effect)
    sign : int
        == 1  : Shadowing NLOS situation
        ==-1  : No shadowing LOS situation   


    Notes
    -----

    Provides an implementation of formula (6.6) in D1.4 of METIS project


    See Also
    --------

    LossMetisShadowing


    &quot;&quot;&quot;
    lamda = 0.3/fGHz
    F = np.arctan(sign*np.pi/2.*(np.sqrt((np.pi/lamda)*(D-r)))) / np.pi
    return(F)</div>

<div class="viewcode-block" id="LossMetisShadowing"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.LossMetisShadowing.html#pylayers.antprop.loss.LossMetisShadowing">[docs]</a>def LossMetisShadowing(fGHz,tx,rx,pg,uw,uh,w,h):
    &quot;&quot;&quot; Calculate the Loss from 

    Parameters
    ----------
    fGHz : float
        
    tx  : np.array (,3) of floats  
        transmiter coordinates 
    rx  : np.array (,3) of floats  
        receiver coordinates 
    pg  : np.array (,3) of floats 
        center of gravity of the screen 
    uw  : np.array (,3) of floats 
        unitary vector along width dimension
    uh  : np.array (,3) of floats 
        unitary vector along height dimension
    w   : float 
        width in meters
    h   : float 
        height in meters 

    Returns
    -------

    Lsh : float 
        Loss in dB to add to the FS path Loss


    Notes
    -----

    This function provides an implementation of formula 6.5 of D1.4 deliverable of METIS project

    [Metis D1.4](Ahttps://www.metis2020.com/wp-content/uploads/METIS_D1.4_v3.pdf)

    # geometry parametric issue : find M in [tx-rx] defined as M = alpha*rx + (1-alpha)tx where alpha in [0-1].
    # if alpha = 0 then M = tx ; if alpha = 1 then M = rx.
    # Besides, M is defined as M = pg + beta*uw + gamma*uh then  alpha*rx + (1-alpha)tx = pg + beta*uw + gamma*uh
    # [rx-tx , -uw, -uh]*[alpha,beta,gamma].T = pg - tx &lt;==&gt; Ax = b solved by la.solve ; x[0]=alpha, x[1]=beta and

    TODO To be vectorized

    &quot;&quot;&quot;



    rxtx = rx - tx # LOS distance

    # x[2]=gamma.
    A = np.vstack((rxtx,-uw,-uh)).T
    b = pg - tx
    x = la.solve(A,b)

    # condition of shadowing
    condseg = ((x[0]&gt;1) or (x[0]&lt;0))
    condw = ((x[1]&gt;w/2.) or (x[1]&lt;-w/2.))
    condh = ((x[2]&gt;h/2.) or (x[2]&lt;-h/2.))

    visi = condseg or condw or condh
    if visi:
        shad = -1
    else:
        shad = 1

    r = np.dot(rxtx,rxtx)**0.5
    w1 = pg + uw*w/2.
    w2 = pg - uw*w/2.
    h1 = pg + uh*h/2.
    h2 = pg - uh*h/2.


    Dtw1 = np.dot(tx-w1,tx-w1)**0.5
    Drw1 = np.dot(rx-w1,rx-w1)**0.5
    Dtw2 = np.dot(tx-w2,tx-w2)**0.5
    Drw2 = np.dot(rx-w2,rx-w2)**0.5
    Dth1 = np.dot(tx-h1,tx-h1)**0.5
    Drh1 = np.dot(rx-h1,rx-h1)**0.5
    Dth2 = np.dot(tx-h2,tx-h2)**0.5
    Drh2 = np.dot(rx-h2,rx-h2)**0.5

    D1w = Dtw1+Drw1
    D1h = Dth1+Drh1
    D2w = Dtw2+Drw2
    D2h = Dth2+Drh2


    if shad == 1:
        signw1 = 1
        signw2 = 1
        signh1 = 1
        signh2 = 1
    else:
        if condw:
            if D1w&gt;D2w:
                signw1=1
                signw2=-1
            else:
                signw1=-1
                signw2=1
        else:
            signw1 = 1
            signw2 = 1
        
        if condh:
            if D1h&gt;D2h:
                signh1=1
                signh2=-1
            else:
                signh1=-1
                signh2=1
        else:
            
            signh1 = 1
            signh2 = 1

    
            
    Fw1 = FMetisShad(fGHz,r,D1w,sign=signw1)
    Fh1 = FMetisShad(fGHz,r,D1h,sign=signh1)
    Fw2 = FMetisShad(fGHz,r,D2w,sign=signw2)
    Fh2 = FMetisShad(fGHz,r,D2h,sign=signh2)
    tmp = (Fh1+Fh2)*(Fw1+Fw2)
    Lsh = -20*np.log10(1-tmp)

    #return(Lsh,shad,tmp,Fw1,Fh1,Fw2,Fh2,condh,condw)
    return(Lsh)</div>

<div class="viewcode-block" id="LossMetisShadowing2"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.LossMetisShadowing2.html#pylayers.antprop.loss.LossMetisShadowing2">[docs]</a>def LossMetisShadowing2(fGHz,tx,rx,pg,uw,uh,w,h):
    &quot;&quot;&quot; Calculate the Loss from 

    Parameters
    ----------

    fGHz : np.array(,Nf)
        
    tx  : np.array (3,Nseg) of floats  
        transmiter coordinates 
    rx  : np.array (3,Nseg) of floats  
        receiver coordinates 
    pg  : np.array (3,Nscreen) of floats 
        center of gravity of the screen 
    uw  : np.array (3,Nscreen) of floats 
        unitary vector along width dimension
    uh  : np.array (3,Nscreen) of floats 
        unitary vector along height dimension
    w   : np.array (,Nscreen)
        width in meters
    h   : np.array (,Nscreen)
        height in meters 

    Returns
    -------

    Lsh : np.array (Nseg,Nscreen,Nf)
        Loss in dB to add to the FS path Loss


    Notes
    -----

    This function provides an implementation of formula 6.5 of D1.4 deliverable of METIS project

    [Metis D1.4](Ahttps://www.metis2020.com/wp-content/uploads/METIS_D1.4_v3.pdf)

    # geometry parametric issue : find M in [tx-rx] defined as M = alpha*rx + (1-alpha)tx where alpha in [0-1].
    # if alpha = 0 then M = tx ; if alpha = 1 then M = rx.
    # Besides, M is defined as M = pg + beta*uw + gamma*uh then  alpha*rx + (1-alpha)tx = pg + beta*uw + gamma*uh
    # [rx-tx , -uw, -uh]*[alpha,beta,gamma].T = pg - tx &lt;==&gt; Ax = b solved by la.solve ; x[0]=alpha, x[1]=beta and

    
    &quot;&quot;&quot;

    Nseg = tx.shape[1]
    Nscreen = uw.shape[1]

    rxtx = rx - tx # (3,Nseg) LOS distance
   

    # A : (Nseg,Nscreen,3,3)
    # b : (Nseg,Nscreen,3)
    # rxtx.T (Nseg,3)
    # uw.T (Nscreen, 3)
    # uh.T (Nscreen, 3)

    U = rxtx.T[:,None,:,None]
    W = uw.T[None,:,:,None]
    H = uh.T[None,:,:,None]

    We = W + np.zeros(U.shape)
    He = H + np.zeros(U.shape)
    Ue = U + np.zeros(He.shape)

    A = np.concatenate((Ue,-We,-He),axis=3)
    #A = np.vstack((rxtx,-uw,-uh)).T 

    # pg.T Nscreen, 3
    # tx.T Nseg,3
    b = pg.T[None,:,:]-tx.T[:,None,:] 
    #b = pg - tx
    x = la.solve(A,b)
    
    
    # condition of shadowing
    condseg = ((x[:,:,0]&gt;1) + (x[:,:,0]&lt;0)) 
    condw = ((x[:,:,1]&gt;w[None,:]/2.) + (x[:,:,1]&lt;-w[None,:]/2.)) 
    condh = ((x[:,:,2]&gt;h[None,:]/2.) + (x[:,:,2]&lt;-h[None,:]/2.)) 
    
    visi = (condseg + condw + condh)%2

    
    # if visi:
    #     shad = -1
    # else:
    #     shad = 1
    #shad = - visi    
    
    r = np.sum(rxtx*rxtx,axis=0)**0.5


    w1 = pg + uw*w[None,:]/2.
    w2 = pg - uw*w[None,:]/2.
    h1 = pg + uh*h[None,:]/2.
    h2 = pg - uh*h[None,:]/2.


    
    Dtw1 = np.sum((tx[...,None]-w1[:,None,:])*(tx[...,None]-w1[:,None,:]),axis=0)**0.5
    Drw1 = np.sum((rx[...,None]-w1[:,None,:])*(rx[...,None]-w1[:,None,:]),axis=0)**0.5
    Dtw2 = np.sum((tx[...,None]-w2[:,None,:])*(tx[...,None]-w2[:,None,:]),axis=0)**0.5
    Drw2 = np.sum((rx[...,None]-w2[:,None,:])*(rx[...,None]-w2[:,None,:]),axis=0)**0.5

    Dth1 = np.sum((tx[...,None]-h1[:,None,:])*(tx[...,None]-h1[:,None,:]),axis=0)**0.5
    Drh1 = np.sum((rx[...,None]-h1[:,None,:])*(rx[...,None]-h1[:,None,:]),axis=0)**0.5
    Dth2 = np.sum((tx[...,None]-h2[:,None,:])*(tx[...,None]-h2[:,None,:]),axis=0)**0.5
    Drh2 = np.sum((rx[...,None]-h2[:,None,:])*(rx[...,None]-h2[:,None,:]),axis=0)**0.5

    # Drw1 = np.dot(rx-w1,rx-w1)**0.5
    # Dtw2 = np.dot(tx-w2,tx-w2)**0.5
    # Drw2 = np.dot(rx-w2,rx-w2)**0.5
    # Dth1 = np.dot(tx-h1,tx-h1)**0.5
    # Drh1 = np.dot(rx-h1,rx-h1)**0.5
    # Dth2 = np.dot(tx-h2,tx-h2)**0.5
    # Drh2 = np.dot(rx-h2,rx-h2)**0.5
    
    
    D1w = Dtw1+Drw1
    D1h = Dth1+Drh1
    D2w = Dtw2+Drw2
    D2h = Dth2+Drh2
    
    signw1 = np.ones((Nseg,Nscreen))
    signw2 = np.ones((Nseg,Nscreen))
    signh1 = np.ones((Nseg,Nscreen))
    signh2 = np.ones((Nseg,Nscreen))


    condw1 = (visi*condw*(D1w&lt;=D2w)).astype(bool)
    condw2 = (visi*condw*(D1w&gt;D2w)).astype(bool)
    signw1[condw1]=-1
    signw2[condw2]=-1
    condh1 = (visi*condh*(D1h&lt;=D2h)).astype(bool)
    condh2 = (visi*condh*(D1h&gt;D2h)).astype(bool)
    signh1[condh1]=-1
    signh2[condh2]=-1


    Fw1 = FMetisShad2(fGHz,r,D1w,sign=signw1)
    Fh1 = FMetisShad2(fGHz,r,D1h,sign=signh1)
    Fw2 = FMetisShad2(fGHz,r,D2w,sign=signw2)
    Fh2 = FMetisShad2(fGHz,r,D2h,sign=signh2)
    tmp = (Fh1+Fh2)*(Fw1+Fw2)
    Lsh = -20*np.log10(1-tmp)

    #return(Lsh,shad,tmp,Fw1,Fh1,Fw2,Fh2,condh,condw)
    return(Lsh)</div>

<div class="viewcode-block" id="Dgrid_zone"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.Dgrid_zone.html#pylayers.antprop.loss.Dgrid_zone">[docs]</a>def Dgrid_zone(zone,Px):
    &quot;&quot;&quot; Distance point to zone

    A zone is a quadrilateral zone.

    Parameters
    ----------

    zone : dictionnary
           xmin xmax Nx
           ymin ymax Ny

    Px : np.array
         point

    Returns
    -------

    D : np.array Nx x Ny
        Euclidian distance matrix

    Notes
    -----

    Build the distance matrix between Tx and points in the zone

    use broadcasting instead

    &quot;&quot;&quot;

    rx = np.linspace(zone[&#39;xmin&#39;],zone[&#39;xmax&#39;],zone[&#39;Nx&#39;])
    ry = np.linspace(zone[&#39;ymin&#39;],zone[&#39;ymax&#39;],zone[&#39;Ny&#39;])

    R_x = np.outer(np.ones(len(ry)),rx)
    R_y = np.outer(ry,np.ones(len(rx)))

    Dx = R_x - Px[0]
    Dy = R_y - Px[1]
    D = np.sqrt(Dx*Dx+Dy*Dy)
    return (D)</div>

<div class="viewcode-block" id="OneSlopeMdl"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.OneSlopeMdl.html#pylayers.antprop.loss.OneSlopeMdl">[docs]</a>def OneSlopeMdl(D,n,fGHz):
    &quot;&quot;&quot; one slope model

    Parameters
    ----------

    D   : np.array
          distance array
    n   : float
          path loss exponent
    fGHz : np.array
           frequency  GHz

    Returns
    -------

    PL : np.array
          path loss as a function of distance

    &quot;&quot;&quot;

    PL = PL0(fGHz) + 10*n*np.log10(D)

    return(PL)</div>

<div class="viewcode-block" id="cost231"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.cost231.html#pylayers.antprop.loss.cost231">[docs]</a>def cost231(pBS,pMS,hroof,phir,wr,fMHz,wb=20,dB=True,city=&#39;medium&#39;):
    &quot;&quot;&quot; Walfish Ikegami model (COST 231)

    Parameters
    ----------

    pBS   : np.array (3xNlink)
    pMS   : np.array (3xNlink)
    hroof : np.array (1xNlink)
    phir  : np.array (1xNlink)
        degrees
    wr    : np.array (1xNlink)
    fMHz  : np.array (1xNf)
    wb    : float
        average building separation
    dB    : boolean

    Returns
    -------

    PathLoss  (Nlink,Nf)

    References
    ----------

    http://morse.colorado.edu/~tlen5510/text/classwebch3.html

    Examples
    --------

    .. plot::
        :include-source:

        &gt;&gt;&gt; from pylayers.antprop.loss import *
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; # Number of links and BS and MS heights
        &gt;&gt;&gt; Nlink = 100
        &gt;&gt;&gt; hBS = 300
        &gt;&gt;&gt; hMS = 1.5
        &gt;&gt;&gt; # hroof and phir are drawn uniformily at random 
        &gt;&gt;&gt; hroof = 40*np.random.rand(Nlink)
        &gt;&gt;&gt; wr = 10*np.ones(Nlink)
        &gt;&gt;&gt; phir = 90*np.random.rand(Nlink)
        &gt;&gt;&gt; pMS = np.vstack((np.linspace(10,2500,Nlink),np.zeros(Nlink),hMS*np.ones(Nlink)))
        &gt;&gt;&gt; pBS = np.vstack((np.zeros(Nlink),np.zeros(Nlink),hBS*np.ones(Nlink)))
        &gt;&gt;&gt; # frequency range 
        &gt;&gt;&gt; fMHz = np.linspace(700,1900,120)
        &gt;&gt;&gt; pl = cost231(pBS,pMS,hroof,phir,wr,fMHz)
        &gt;&gt;&gt; im = plt.imshow(pl,extent=(0,100,0.7,1.9))
        &gt;&gt;&gt; cb = plt.colorbar()
        &gt;&gt;&gt; cb.set_label(&#39;Loss (dB)&#39;)
        &gt;&gt;&gt; plt.axis(&#39;tight&#39;)
        &gt;&gt;&gt; plt.xlabel(&#39;Frequency (GHz)&#39;)
        &gt;&gt;&gt; plt.ylabel(&#39;Link Number&#39;)
        &gt;&gt;&gt; plt.title(&#39;100 WI Path Loss realizations &#39;)
        &gt;&gt;&gt; plt.show()

    &quot;&quot;&quot;

    hBS = pBS[2,:][:,np.newaxis]
    hMS = pMS[2,:][:,np.newaxis]
    wr  = wr[:,np.newaxis]
    hroof = hroof[:,np.newaxis]
    phir = phir[:,np.newaxis]
    fMHz = fMHz[np.newaxis,:]
    dm  = np.sqrt(np.sum((pBS-pMS)*(pBS-pMS),axis=0))[:,np.newaxis]
    dkm = dm/1000.
    Nlink = len(dm)

    pl0 = 32.4 + 20*np.log10(dkm) + 20*np.log10(fMHz)

    delta_base = hBS-hroof

    u035  = np.where((phir&gt;=0) &amp; (phir&lt;35))
    u3555 = np.where((phir&gt;=35) &amp; (phir&lt;55))
    u5590 = np.where((phir&gt;=55) &amp; (phir&lt;90))

    plori = np.zeros(Nlink)[:,np.newaxis]
    # path loss due to orientation w.r.t road
    plori[u035] = -10+0.354*phir[u035]
    plori[u3555] = 2.5+0.075*phir[u3555]
    plori[u5590] = 4.0-0.114*(phir[u5590]-55)

    # rooftop to street
    plrts = -16.9-10*np.log10(wr)+10*np.log10(fMHz)+20*np.log10(hroof-hMS)+plori
    uroofsupBS  = np.where(hBS&gt;hroof)
    uroofinfBS  = np.where(hBS&lt;=hroof)
    udistsup500 = np.where((hBS&lt;=hroof)&amp;(dkm&gt;0.5))
    udistinf500 = np.where((hBS&lt;=hroof)&amp;(dkm&lt;0.5))

    plbsh = np.zeros((Nlink,1))
    plbsh[uroofsupBS] = -18*np.log10(1+delta_base[uroofsupBS])

    ka  = 54*np.ones((Nlink,1))
    ka[udistsup500] = ka[udistsup500]-0.8*delta_base[udistsup500]
    ka[udistinf500] = ka[udistinf500]-0.8*delta_base[udistinf500]*dkm[udistinf500]/0.5

    kd  = 18*np.ones((Nlink,1))
    kd[uroofinfBS] = kd[uroofinfBS]-15*delta_base[uroofinfBS]/hroof[uroofinfBS]

    if city==&#39;medium&#39;:
        kf = -4+0.7*(fMHz/925.-1)
    else:
        kf = -4+1.5*(fMHz/925.-1)

    plmsd = plbsh+ka+kd*np.log10(dkm)+kf*np.log10(fMHz)-9*np.log10(wb)

    pl = pl0
    padd = plmsd + plrts
    ulosspos = np.where(padd&gt;0)[0]
    pl[ulosspos]=pl[ulosspos]+padd[ulosspos]

    if not dB:
        pl = 10**(-pl/20.)

    return(pl)</div>

<div class="viewcode-block" id="cost259"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.cost259.html#pylayers.antprop.loss.cost259">[docs]</a>def cost259(pMS,pBS,fMHz):
    &quot;&quot;&quot; cost259 model

    Parameters
    ----------

    pMS : np.array (position of Mobile Station)
    pBS : np.array (position of Base station)
    fMHz : float

    &quot;&quot;&quot;

    dm  = np.sqrt((pBS-pMS)*(pBS-pMS))
    lmbd = 300/fMHz
    pl = 10*2.6*np.log10(dm)+20*log10(4*np.pi/lmbd)

    if not dB:
        pl = 10**(-pl/20.);
    return(pl)</div>

<div class="viewcode-block" id="hata"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.hata.html#pylayers.antprop.loss.hata">[docs]</a>def hata(pMS,pBS,fGHz,hMS,hBS,typ):
    &quot;&quot;&quot; Hata Path loss model

    Parameters
    ----------

    pMS : np.array
        Mobile position (meters)
    pBS : np.array
        Base station position (meters)
    fGHz : np.array
    hMS : height mobile station (m)
    hBS : height base station (m)
    typ : &#39;small&#39; or &#39;big&#39;

    Returns
    -------

    L : Attenuation (dB)

    Examples
    --------

        &gt;&gt;&gt; d = np.linspace(100,5000,120)
        &gt;&gt;&gt; hBS = 30
        &gt;&gt;&gt; hMS = 1.5
        &gt;&gt;&gt; fGHz = 0.9
        &gt;&gt;&gt; pMS = np.array([d,0,hMS])
        &gt;&gt;&gt; pBS = np.array([d,0,hBS])
        &gt;&gt;&gt; L = hata(pMS,pBS,fGHz,hMS,hBS,&#39;small&#39;)

    Notes
    -----

    This model is valid until 1.5GHz, for higher frequency see
    COST231-Hata model

    References
    ----------

    OKUMURA (Y.), OHMORI (E.), KAWANO (T.)
    et FUKUA (K.).  Field strength and its varia-
    bility in UHF and VHF land-mobile radio ser-
    vice. Rev. Elec. Commun. Lab., vol. 16, n o 9,
    1968.

    HATA (M.).  Empirical formula for propaga-
    tion loss in land mobile radio services. IEEE
    Trans. Veh. Technol., vol. 29, pp. 317-325,
    Aug. 1980

    &quot;&quot;&quot;
    dm  = np.sqrt((pBS-pMS)*(pBS-pMS))
    if (typ==&#39;small&#39;):
       CH = (1.1*np.log10(fGHz*1000)-0.7)*hMS-(1.56*np.log10(fGHz*1000)-0.8)
    if (typ==&#39;big&#39;):
        if fGHz&lt;0.2:
            CH = 8.29*(np.log10(1.54*hMS)**2)-1.1
        else:# valid until 1.5GHz
            CH = 3.2*(np.log10(11.75*hMS)**2)-4.97

    L = 69.55+26.16*np.log10(fGHz*1000)-13.82*np.log10(hBS)+(44.9-6.55*np.log10(hBS))*np.log10(dm/1000.)-CH

    return(L)</div>

<div class="viewcode-block" id="cost2100"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.cost2100.html#pylayers.antprop.loss.cost2100">[docs]</a>def cost2100(pMS,pBS,fGHz,nfloor=1,dB=True):
    &quot;&quot;&quot; cost 2100 model

    Parameters
    ----------

    pMS :
    pBS :
    fGHz : float
    nfloor : int
    dB : boolean

    &quot;&quot;&quot;
    # distance (meters)
    dm  = np.sqrt((pBS-pMS)*(pBS-pMS))
    pl0 = 32.4+20*log10(dm)+20*np.log10(fGHz)
    pld = nfloor*30
    pl  = pl0+pld
    if not dB:
        pl = 10**(-pl/20.)
    return(pl)</div>

<div class="viewcode-block" id="PL"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.PL.html#pylayers.antprop.loss.PL">[docs]</a>def PL(fGHz,pts,p,n=2.0,dB=True,d0=1):
    &quot;&quot;&quot; calculate Free Space Path Loss

    Parameters
    ----------

    fGHz   : float
             frequency (GHz)
    pts    : np.array (2xNp)
             points
    p      : np.array (2x1) or (2xNp)
    n      : float
            path loss exponent (default = 2)

    dB : : boolean
        return result in dB


    Returns
    -------

    PL : np.array
         path loss w.r.t distance and frequency

    &quot;&quot;&quot;
    shp = np.shape(p)
    # assert(shp[0]==2)

    D = np.sqrt(np.sum((pts-p)**2,axis=0))
    # f x grid x ap
    #PL = np.array([PL0(fGHz)])[:,np.newaxis] + 10*n*np.log10(D)[np.newaxis,:]

    PL = PL0(fGHz,d0)[:,np.newaxis] + 10*n*np.log10(D/d0)[np.newaxis,:]

    if not dB:
        PL=10**(-PL/10)

    return(PL)</div>

<div class="viewcode-block" id="Losst"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.Losst.html#pylayers.antprop.loss.Losst">[docs]</a>def Losst(L,fGHz,p1,p2,dB=True):
    &quot;&quot;&quot;  calculate Losses between links p1 p2

    Parameters
    ----------

    L   : Layout object
    fGHz : np.array
           frequency GHz
    p1 : source points
        (2 x Np1) array or (2,) array
    p2 : observation point
        (2 x Np2) array or (2,) array
    dB : boolean

    Examples
    --------

    .. plot::
        :include-source:

        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; from pylayers.measures.mesuwb import *
        &gt;&gt;&gt; from pylayers.antprop.loss import *
        &gt;&gt;&gt; S = Simul()
        &gt;&gt;&gt; S.layout(&#39;WHERE1.lay&#39;)
        &gt;&gt;&gt; fGHz = 4
        &gt;&gt;&gt; Tx,Rx = ptw1()
        &gt;&gt;&gt; Lwo,Lwp,Edo,Edp = Losst(S.L,fGHz,Tx.T,Rx[1,0:2],dB=True)
        &gt;&gt;&gt; fig=plt.figure(figsize=(20,10))
        &gt;&gt;&gt; fig,ax = S.L.showGs(fig=fig)
        &gt;&gt;&gt; tit = plt.title(&#39;test Losst&#39;)
        &gt;&gt;&gt; sc2 = ax.scatter(Rx[1,0],Rx[1,1],s=20,marker=&#39;x&#39;,c=&#39;k&#39;)
        &gt;&gt;&gt; sc1 = ax.scatter(Tx[:,0],Tx[:,1],s=20,c=Lwo,linewidth=0)
        &gt;&gt;&gt; cb = plt.colorbar(sc1)
        &gt;&gt;&gt; cb.set_label(&#39;dB&#39;)
        &gt;&gt;&gt; plt.show()

    See Also
    --------

    pylayers.antprop.coverage
    pylayers.slab.Interface.losst

    &quot;&quot;&quot;

    if (type(fGHz)==float) | (type(fGHz)==int):
        fGHz=np.array([fGHz],dtype=float)

    sh1 = np.shape(p1)
    sh2 = np.shape(p2)

    if (len(sh1)&gt;1) &amp; (len(sh2)&gt;1):
        Nlink = max(sh1[1],sh2[1])
    if (len(sh1)&gt;1) &amp; (len(sh2)&lt;2):
        Nlink = sh1[1]
    if (len(sh1)&lt;2) &amp; (len(sh2)&gt;1):
        Nlink = sh2[1]
    if (len(sh1)&lt;2) &amp; (len(sh2)&lt;2):
        Nlink = 1

    # determine incidence angles on segment crossing p1-p2 segment
    #data = L.angleonlink(p1,p2)
    data = L.angleonlink3(p1,p2)
    
    # as many slabs as segments and subsegments
    us    = data[&#39;s&#39;] 
    slabs = np.array([ L.Gs.node[x][&#39;name&#39;] for x in us ])





    #slabs = L.sla[us]
    check = np.where(slabs==&#39;&#39;)

    #
    # As segment numbering is not necessarily contiguous 
    # there exist void string &#39;&#39; in slabs
    cslab = list(np.unique(slabs))
    if &#39;&#39; in cslab:
        cslab.remove(&#39;&#39;)
    if &#39;AIR&#39; in cslab:
        cslab.remove(&#39;AIR&#39;)
    if &#39;_AIR&#39; in cslab:
        cslab.remove(&#39;_AIR&#39;)


    LossWallo = np.zeros((len(fGHz),Nlink))
    LossWallp = np.zeros((len(fGHz),Nlink))
    EdWallo = np.zeros((len(fGHz),Nlink))
    EdWallp = np.zeros((len(fGHz),Nlink))

    for slname in cslab:
        # u index of slabs of name slname
        # data[&#39;a&#39;][u] angle
        # data[&#39;s&#39;][u] segment number including subsegment
        u = np.nonzero(np.array(slabs)==slname)[0]
        #
        # calculate Loss for slab slname
        #
        lko,lkp  = L.sl[slname].losst(fGHz,data[&#39;a&#39;][u])
        #
        # calculate Excess delay for slab slname
        #
        do , dp  = L.sl[slname].excess_grdelay(theta=data[&#39;a&#39;][u])
        # data[&#39;i&#39;][u] links number
        indexu = data[&#39;i&#39;][u]
        # reduce to involved links
        involved_links, indices = np.unique(indexu,return_index=True)
        indicep = np.hstack((indices[1:],np.array([len(indexu)])))
        # range on involved links
        irange = np.arange(len(involved_links))
        #
        # sum contribution of slab of a same link
        #
        Wallo = np.array([ np.sum(lko[:,indices[x]:indicep[x]],axis=1) for x in irange ] ).T
        Wallp = np.array([ np.sum(lkp[:,indices[x]:indicep[x]],axis=1) for x in irange ] ).T

        Edo = np.array([np.sum(do[indices[x]:indicep[x]]) for x in irange]).T
        Edp = np.array([np.sum(dp[indices[x]:indicep[x]]) for x in irange]).T

        LossWallo[:,involved_links] = LossWallo[:,involved_links] + Wallo
        LossWallp[:,involved_links] = LossWallp[:,involved_links] + Wallp

        EdWallo[:,involved_links] = EdWallo[:,involved_links] + Edo
        EdWallp[:,involved_links] = EdWallp[:,involved_links] + Edp


    # Managing Ceil / Floor transmission


    # check crossing ceil
    if (p1[2,:]&gt; L.zceil).any() or (p2[2,:]&gt; L.zceil).any():

        # WARNING : this test sohould be done individually
        if (p1[2]&gt;p2[2]).all():
            v0 = p1
            v1 = p2
        else:
            v0 = p2
            v1 = p1

        uu = v0 - v1
        # 1 x N
        nu = np.sqrt(np.sum(uu * uu, axis=0))
        # 3 x N
        un = uu / nu[np.newaxis, :]
        dotp = np.einsum(&#39;ij,i-&gt;j&#39;,un,np.array([0,0,1]))
        alphas = np.arccos(dotp)

        #
        # calculate Loss for slab CEIL
        #
        lkco,lkcp  = L.sl[&#39;CEIL&#39;].losst(fGHz,alphas)
        #
        # calculate Excess delay for slab CEIL
        #
        dco , dcp  = L.sl[&#39;CEIL&#39;].excess_grdelay(theta=alphas)



        LossWallo = LossWallo + lkco
        LossWallp = LossWallp + lkcp

        EdWallo = EdWallo + dco
        EdWallp = EdWallp + dcp


    # check crossing floor
    if (p1[2,:]&lt; L.zfloor).any() or (p2[2,:]&lt; L.zfloor).any():


        # WARNING : this test sohould be done individually
        if (p1[2]&gt;p2[2]).all():
            v0 = p1
            v1 = p2
        else:
            v0 = p2
            v1 = p1

        uu = v0 - v1
        # 1 x N
        nu = np.sqrt(np.sum(uu * uu, axis=0))
        # 3 x N
        un = uu / nu[np.newaxis, :]
        dotp = np.einsum(&#39;ij,i-&gt;j&#39;,un,np.array([0,0,1]))
        alphas = np.arccos(dotp)

        #
        # calculate Loss for slab CEIL
        #
        lkfo,lkfp  = L.sl[&#39;FLOOR&#39;].losst(fGHz,alphas)
        #
        # calculate Excess delay for slab CEIL
        #
        dfo , dfp  = L.sl[&#39;FLOOR&#39;].excess_grdelay(theta=alphas)



        LossWallo = LossWallo + lkfo
        LossWallp = LossWallp + lkfp

        EdWallo = EdWallo + dfo
        EdWallp = EdWallp + dfp


    if not dB:
        LossWallo = 10**(-LossWallo/10)
        LossWallp = 10**(-LossWallp/10)

    return(LossWallo,LossWallp,EdWallo,EdWallp)</div>

<div class="viewcode-block" id="gaspl"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.gaspl.html#pylayers.antprop.loss.gaspl">[docs]</a>def gaspl(d,fGHz,T,PhPa,wvden):
    &quot;&quot;&quot; attenuation due to atmospheric gases

    Parameters 
    ----------
    d : np.array
        range (meters) 
    fGHz : np.array 
        frequency (GHz)
    T : float 
        Temprature in degree Celcius
    PhPa : float
        Pressure in hPa
    wvden : float
        Water vapor density (g/m**3)

    Examples
    --------

    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; T = 15
    &gt;&gt;&gt; PhPa = 1013
    &gt;&gt;&gt; wvden = 7.5
    &gt;&gt;&gt; d = 1000
    &gt;&gt;&gt; fGHz = np.linspace(1,1000,100)
    &gt;&gt;&gt; L = gaspl(d,fGHz,T,PhPa,wvden)
    &gt;&gt;&gt; plt.plot(fGHz,L)

    Notes
    -----

    This function implements the recommandation UIT-P676-10

    &quot;&quot;&quot;

    affO2=np.array([
    [50.474214,0.975,9.651,6.690,0.0,2.566,6.850],
    [50.987745,2.529,8.653,7.170,0.0,2.246,6.800],
    [51.503360,6.193,7.709,7.640,0.0,1.947,6.729],
    [52.021429,14.320,6.819,8.110,0.0,1.667,6.640],
    [52.542418,31.240,5.983,8.580,0.0,1.388,6.526],
    [53.066934,64.290,5.201,9.060,0.0,1.349,6.206],
    [53.595775,124.600,4.474,9.550,0.0,2.227,5.085],
    [54.130025,227.300,3.800,9.960,0.0,3.170,3.750],
    [54.671180,389.700,3.182,10.370,0.0,3.558,2.654],
    [55.221384,627.100,2.618,10.890,0.0,2.560,2.952],
    [55.783815,945.300,2.109,11.340,0.0,-1.172,6.135],
    [56.264774,543.400,0.014,17.030,0.0,3.525,-0.978],
    [56.363399,1331.800,1.654,11.890,0.0,-2.378,6.547],
    [56.968211,1746.600,1.255,12.230,0.0,-3.545,6.451],
    [57.612486,2120.100,0.910,12.620,0.0,-5.416,6.056],
    [58.323877,2363.700,0.621,12.950,0.0,-1.932,0.436],
    [58.446588,1442.100,0.083,14.910,0.0,6.768,-1.273],
    [59.164204,2379.900,0.387,13.530,0.0,-6.561,2.309],
    [59.590983,2090.700,0.207,14.080,0.0,6.957,-0.776],
    [60.306056,2103.400,0.207,14.150,0.0,-6.395,0.699],
    [60.434778,2438.000,0.386,13.390,0.0,6.342,-2.825],
    [61.150562,2479.500,0.621,12.920,0.0,1.014,-0.584],
    [61.800158,2275.900,0.910,12.630,0.0,5.014,-6.619],
    [62.411220,1915.400,1.255,12.170,0.0,3.029,-6.759],
    [62.486253,1503.000,0.083,15.130,0.0,-4.499,0.844],
    [62.997984,1490.200,1.654,11.740,0.0,1.856,-6.675],
    [63.568526,1078.000,2.108,11.340,0.0,0.658,-6.139],
    [64.127775,728.700,2.617,10.880,0.0,-3.036,-2.895],
    [64.678910,461.300,3.181,10.380,0.0,-3.968,-2.590],
    [65.224078,274.000,3.800,9.960,0.0,-3.528,-3.680],
    [65.764779,153.000,4.473,9.550,0.0,-2.548,-5.002],
    [66.302096,80.400,5.200,9.060,0.0,-1.660,-6.091],
    [66.836834,39.800,5.982,8.580,0.0,-1.680,-6.393],
    [67.369601,18.560,6.818,8.110,0.0,-1.956,-6.475],
    [67.900868,8.172,7.708,7.640,0.0,-2.216,-6.545],
    [68.431006,3.397,8.652,7.170,0.0,-2.492,-6.600],
    [68.960312,1.334,9.650,6.690,0.0,-2.773,-6.650],
    [118.750334,940.300,0.010,16.640,0.0,-0.439,0.079],
    [368.498246,67.400,0.048,16.400,0.0,0.000,0.000],
    [424.763020,637.700,0.044,16.400,0.0,0.000,0.000],
    [487.249273,237.400,0.049,16.000,0.0,0.000,0.000],
    [715.392902,98.100,0.145,16.000,0.0,0.000,0.000],
    [773.839490,572.300,0.141,16.200,0.0,0.000,0.000],
    [834.145546,183.100,0.145,14.700,0.0,0.000,0.000]])
    ## spectroscopic data for H20
    ## f0 b1 b2 b3 b4 b5 b6
    affH2O=np.array([
    [22.235080,0.1130,2.143,28.11,0.69,4.800,1.00],
    [67.803960,0.0012,8.735,28.58,0.69,4.930,0.82],
    [119.995940,0.0008,8.356,29.48,0.70,4.780,0.79],
    [183.310091,2.4200,0.668,30.50,0.64,5.300,0.85,],
    [321.225644,0.0483,6.181,23.03,0.67,4.690,0.54],
    [325.152919,1.4990,1.540,27.83,0.68,4.850,0.74],
    [336.222601,0.0011,9.829,26.93,0.69,4.740,0.61],
    [380.197372,11.5200,1.048,28.73,0.54,5.380,0.89,],
    [390.134508,0.0046,7.350,21.52,0.63,4.810,0.55],
    [437.346667,0.0650,5.050,18.45,0.60,4.230,0.48,],
    [439.150812,0.9218,3.596,21.00,0.63,4.290,0.52,],
    [443.018295,0.1976,5.050,18.60,0.60,4.230,0.50],
    [448.001075,10.3200,1.405,26.32,0.66,4.840,0.67],
    [470.888947,0.3297,3.599,21.52,0.66,4.570,0.65,],
    [474.689127,1.2620,2.381,23.55,0.65,4.650,0.64],
    [488.491133,0.2520,2.853,26.02,0.69,5.040,0.72],
    [503.568532,0.0390,6.733,16.12,0.61,3.980,0.43],
    [504.482692,0.0130,6.733,16.12,0.61,4.010,0.45],
    [547.676440,9.7010,0.114,26.00,0.70,4.500,1.00],
    [552.020960,14.7700,0.114,26.00,0.70,4.500,1.00],
    [556.936002,487.4000,0.159,32.10,0.69,4.110,1.00],
    [620.700807,5.0120,2.200,24.38,0.71,4.680,0.68],
    [645.866155,0.0713,8.580,18.00,0.60,4.000,0.50],
    [658.005280,0.3022,7.820,32.10,0.69,4.140,1.00],
    [752.033227,239.6000,0.396,30.60,0.68,4.090,0.84],
    [841.053973,0.0140,8.180,15.90,0.33,5.760,0.45],
    [859.962313,0.1472,7.989,30.60,0.68,4.090,0.84],
    [899.306675,0.0605,7.917,29.85,0.68,4.530,0.90],
    [902.616173,0.0426,8.432,28.65,0.70,5.100,0.95],
    [906.207325,0.1876,5.111,24.08,0.70,4.700,0.53],
    [916.171582,8.3400,1.442,26.70,0.70,4.780,0.78],
    [923.118427,0.0869,10.220,29.00,0.70,5.000,0.80],
    [970.315022,8.9720,1.920,25.50,0.64,4.940,0.67],
    [987.926764,132.1000,0.258,29.85,0.68,4.550,0.90],
    [1780.000000,22,300.0000,0.952,176.20,0.50,30.500]])
    
    dkm = d/1000.
    TK = T + 273.15
    theta = 300./TK #3

    fO2 = affO2[:,0]
    a1 = affO2[:,1]
    a2 = affO2[:,2]
    a3 = affO2[:,3]
    a4 = affO2[:,4]
    a5 = affO2[:,5]
    a6 = affO2[:,6]
    fH2O = affH2O[:,0]
    b1 = affH2O[:,1]
    b2 = affH2O[:,2]
    b3 = affH2O[:,3]
    b4 = affH2O[:,4]
    b5 = affH2O[:,5]
    b6 = affH2O[:,6]
    e = wvden*TK/216.7  # 4

    SO2  = a1*1e-7*PhPa*(theta**3)*np.exp(a2*(1-theta))  # 3
    DO2  = a3*1e-4*(PhPa*(theta**(0.8-a4))+1.1*e*theta)  # 6a

    SH2O = b1*1e-1*e*(theta**(3.5))*np.exp(b2*(1-theta)) # 3
    DH2O = b3*1e-4*(PhPa*theta**b4+b5*e*theta**b6)  # 6a

    DO2_m = np.sqrt(DO2**2+2.25e-6) # 6b
    DH2O_m = 0.535*DH2O+np.sqrt(0.217*DH2O**2+(2.1316*1e-12*fH2O**2)/theta)
    deltaO2 = (a5+a6*theta)*1e-4*(PhPa+e)*theta**(0.8)
    #
    #  O2
    #
    uO2 = fO2[:,None]-fGHz[None,:]
    vO2 = fO2[:,None]+fGHz[None,:]
    n1O2 = DO2_m[:,None]-deltaO2[:,None]*uO2
    n2O2 = DO2_m[:,None]-deltaO2[:,None]*vO2
    d1O2 = uO2**2 + DO2_m[:,None]**2
    d2O2 = vO2**2 + DO2_m[:,None]**2
    FO2 = (fGHz[None,:]/fO2[:,None])*(n1O2/d1O2+n2O2/d2O2)
    UO2 = SO2[:,None]*FO2
    #
    # H2O
    #
    uH2O = fH2O[:,None]-fGHz[None,:]
    vH2O = fH2O[:,None]+fGHz[None,:]
    nH2O = DH2O_m[:,None]
    d1H2O = uH2O**2 + DH2O_m[:,None]**2
    d2H2O = vH2O**2 + DH2O_m[:,None]**2
    FH2O = (fGHz[None,:]/fH2O[:,None])*(nH2O/d1H2O+nH2O/d2H2O)
    UH2O = SH2O[:,None]*FH2O

    # Nsec  (8)
    
    dD = 5.6e-4*(PhPa+e)*theta**(0.8)
    t1 = 6.14e-5/(dD*(1.+(fGHz/dD)**2))
    t2 = 1.4e-12*PhPa*(theta**(1.5))/(1+1.9e-5*fGHz**(1.5))
    Nsec = fGHz*PhPa*(theta**2)*(t1+t2)  # 9 
    
    ulow  = np.where(fGHz&lt;118.750343)[0]
    uhigh = np.where(fGHz&gt;=118.750343)[0] 
    UO2low = UO2[:,ulow]
    UO2high = UO2[:,uhigh] 
    SO2low  = np.sum(UO2low,axis=0)
    SO2high = np.sum(UO2high[38:,:],axis=0)
    sSO2 = np.hstack((SO2low,SO2high))
    Npp = sSO2 + np.sum(UH2O,axis=0)+Nsec
    Npp = np.sum(UO2,axis=0) + np.sum(UH2O,axis=0)+Nsec
    gamma = 0.1820*fGHz*Npp 
    LgasdB = gamma*dkm 

    return(LgasdB)</div>


<div class="viewcode-block" id="Loss0"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.Loss0.html#pylayers.antprop.loss.Loss0">[docs]</a>def Loss0(S,rx,ry,f,p):
    &quot;&quot;&quot; calculate Loss through Layers for theta=0 deg

    Parameters
    ----------

    S  : Simulation object
    rx : extremity of link 
    ry : extremity of link 
    fGHz : float
        frequency GHz
    p :

    &quot;&quot;&quot;
    Nx  = len(rx)
    Ny  = len(ry)
    Lw  = np.zeros((Nx,Ny))
    print(shape(Lw))
    i   = 0
    for x in rx:
        j   = 0
        for y in ry:
            Loss = 0
            pxy = np.array([x,y])
            seglist,theta = L.angleonlinkold(p,pxy)
            for k in seglist:
                name = L.name[k]
                lk = L.sl[name].loss0(f)
                Loss  = Loss + lk[0]
            Lw[i,j] = Loss
            j = j+1
        i = i+1
    return(Lw)</div>

<div class="viewcode-block" id="Loss_diff"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.Loss_diff.html#pylayers.antprop.loss.Loss_diff">[docs]</a>def Loss_diff(u):
    &quot;&quot;&quot; calculate Path Loss of the diffraction
    &quot;&quot;&quot;
    if u &lt; -0.7:
        Ld = 0
    elif u &gt; 1.5:
        Ld = 13 + 20*np.log10(u)
    else:
        Ld = 6.9 + 20*np.log10(np.sqrt((u-0.1)**2+1)+u-0.1)

    return(Ld)</div>

<div class="viewcode-block" id="calnu"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.calnu.html#pylayers.antprop.loss.calnu">[docs]</a>def calnu(h,d1,d2,fGHz):
    r&quot;&quot;&quot; Calculate the diffraction Fresnel parameter

    Parameters
    ----------

    h  : signed height w.r.t LOS (meter)
    d1 : distance 1 (meter)
    d2 : distance 2 (meter)
    fGHz  : frequency GHz

    Notes
    -----

    .. math::   \nu = h \sqrt{\frac{2}{\lambda} \frac{d_1+d_2}{d_1 d_2}}

    &quot;&quot;&quot;

    ld = 0.3/fGHz
    nu = h*np.sqrt(2*(d1+d2)/(ld*d1*d2))

    return(nu)</div>


<div class="viewcode-block" id="route"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.route.html#pylayers.antprop.loss.route">[docs]</a>def route(X, Y, Z, Ha, Hb, fGHz, K, method=&#39;deygout&#39;):
    &quot;&quot;&quot; diffraction loss along a route


    Parameters
    ----------

    X : np.array (Nphi,Nr)
        cartesian coordinate grid
    Y : np.array (Nphi,Nr)
        cartesian coordinate grid
    Z : np.array (Nphi,Nr)
        height (meters)

    Ha : float
    Hb : float
    fGHz : np.array (,Nf)
        frequency in GHz
    method : &#39;deygout&#39; | &#39;bullington&#39;

    Returns
    -------

    L : Losses (dB)


    &quot;&quot;&quot;
    Nphi, Nr = Z.shape

    if (type(fGHz) == float):
        fGHz = np.array([fGHz])

    Nf = len(fGHz)
    L = np.zeros((Nphi, Nf))
    L0 = np.zeros(Nf)
    # loop over azimut
    for ip in range(Nphi):
        x = X[ip, :]
        y = Y[ip, :]
        z = Z[ip, :]
        d = np.sqrt((x-x[0])**2+(y-y[0])**2)
        # effect of refraction in equivalent earth curvature
        dh = d*(d[::-1])/(2*K*6375e3)
        z = z + dh
        LOS = 32.4 + 20*np.log10(fGHz) + 20*np.log10(d[-1])
        z[0] = z[0] + Ha
        z[-1] = z[-1] + Hb
        if method == &#39;deygout&#39;:
            LDiff = deygout(d, z, fGHz, L0, 0)
        if method == &#39;bullington&#39;:
            LDiff, deq, heq = bullington(d, z, fGHz)
        L[ip, :] = LDiff+LOS
    return(L)</div>

<div class="viewcode-block" id="cover"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.cover.html#pylayers.antprop.loss.cover">[docs]</a>def cover(X, Y, Z, Ha, Hb, fGHz, K, method=&#39;deygout&#39;):
    &quot;&quot;&quot; outdoor coverage on a region

    Parameters
    ----------

    X : np.array (Nphi,Nr)
        cartesian coordinate grid
    Y : np.array (Nphi,Nr)
        cartesian coordinate grid
    Z : np.array (Nphi,Nr)
        height (meters)

    Ha : float
    Hb : float
    fGHz : np.array (,Nf)
        frequency in GHz
    method : &#39;deygout&#39; | &#39;bullington&#39;

    Returns
    -------

    L : Losses (dB)


    &quot;&quot;&quot;
    Nphi, Nr = Z.shape

    if (type(fGHz) == float):
        fGHz = np.array([fGHz])

    Nf = len(fGHz)
    L = np.zeros((Nphi, Nr, Nf))
    L0 = np.zeros(Nf)
    # loop over azimut
    for ip in range(Nphi):
        # loop over range
        # il : 2 ... Nr-2
        # uk : 0 ....Nr-1
        for il in np.arange(2, Nr-1):
            uk = np.arange(0, il+1)
            z = np.empty(len(uk))
            x = X[ip, uk]
            y = Y[ip, uk]
            z[uk] = Z[ip, uk]
            d = np.sqrt((x-x[0])**2+(y-y[0])**2)
            # effect of refraction in equivalent earth curvature
            dh = d*(d[::-1])/(2*K*6375e3)
            z = z + dh
            LOS = 32.4 + 20*np.log10(fGHz) + 20*np.log10(d[-1])
            z[0] = z[0] + Ha
            z[-1] = z[-1] + Hb
            if method == &#39;deygout&#39;:
                LDiff = deygout(d, z, fGHz, L0, 0)
            if method == &#39;bullington&#39;:
                LDiff, deq, heq = bullington(d, z, fGHz)
            L[ip, il, :] = LDiff[None, :]+LOS[None,:]
    return(L)</div>


<div class="viewcode-block" id="deygout"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.deygout.html#pylayers.antprop.loss.deygout">[docs]</a>def deygout(d, height, fGHz, L, depth):
    &quot;&quot;&quot; Deygout attenuation

    Parameters
    ----------

    d : np.array (,N)
        horizontal distance
    height : np.array (,N)
        height profile
    fGHz : np.array (,Nf)
        frequency GHz
    L : np.array (,Nf)
        Additional Loss
    depth : recursive depth

    Notes
    -----

    This function is recursive

    &quot;&quot;&quot;
    lmbda = 0.3/fGHz
    L0 = np.zeros(len(fGHz))
    depth = depth+1
    N = len(height)
    if depth &lt; 3:
        if N &gt; 3:
            u = np.arange(N)/(N-1.0)  # float
            # l : straight line between termination (LOS)
            l = (height[0])*(1-u)+(height[-1])*u
            # h excludes termination points
            h = height[1:-1] - l[1:-1]
            # Fresnel parameter (engagement)
            nu = h[:, None] * np.sqrt((2/lmbda[None, :]) *
                             (1/d[1:-1, None]+1/(d[-1]-d[1:-1, None])))
            imax = np.unique(np.nanargmax(nu, axis=0))[0]
            numax = nu[imax, :]
        else:
            numax = -10*np.ones(len(fGHz))
        if (numax &gt; -0.78).any():
            w = numax - 0.1
            L = L + np.maximum(6.9 + 20*np.log10(np.sqrt(w**2+1)+w), 0)
            # left link
            height1 = height[0:imax+2]
            d1 = d[0:imax+2]
            Ll = deygout(d1, height1, fGHz, L0, depth)
            # right link
            height2 = height[imax+1:]
            d2 = d[imax+1:]
            Lr = deygout(d2, height2, fGHz, L0, depth)
            # add losses
            L = L + Lr + Ll

    return(L)</div>

<div class="viewcode-block" id="bullington"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.bullington.html#pylayers.antprop.loss.bullington">[docs]</a>def bullington(d, height, fGHz):
    &quot;&quot;&quot; edges attenuation with Bullington method

    Parameters
    ----------

    d : np.array
    height : np.array
        antenna height is includes in height[0] and height[-1]
    fGHz : np.array

    Returns
    -------

    L : np.array
        total loss

    &quot;&quot;&quot;

    def recl(d, height):
        &quot;&quot;&quot; determine left interception point
        Parameters
        ----------
        d : np.array
        height : np.array

        &quot;&quot;&quot;
        N = len(height)
        u = np.arange(N)/(N-1.)
        # l : straight line between termination (LOS)
        l = height[0]*(1-u)+(height[-1])*u
        h = height - l
        # imax : index of the maximum height offset
        imax = np.argmax(h)
        if imax&gt;0:
            # hmax : maximum height offset
            hmax = h[imax]
            # parameterization from 0 to imax
            ul = np.arange(imax)/(imax-1.)
            # straight line
            dhl = h[0]*(1-ul) + hmax*ul
            # el : offset if &lt;0 split again
            el = dhl - h[0:imax]
            if np.min(el) &lt; 0:
                u, v = recl(d[0:imax+1], height[0:imax+1])
            else:
                u = d[0:imax+1]
                v = h[0:imax+1]
        else:
            u = d[0:1]
            v = d[0:1]
        return(u, v)
    #if min(er)&lt;0:
    #    u,v = rec(d[imax-1:-1],dhl)
    #else:
    #er  = dhr - h[imax-1:-1]
    def recr(d, height):
        &quot;&quot;&quot; determine the right interception point
        &quot;&quot;&quot;
        N = len(height)
        u = np.arange(N)/(N-1.)
        l = height[0]*(1-u)+(height[-1])*u
        h = height - l
        imax = np.argmax(h)
        hmax = h[imax]
        ur = np.arange(N-imax)/(N-imax-1.)
        dhr = hmax*(1-ur) + h[-1]*ur

        er = dhr - h[imax:]
        if np.min(er) &lt; 0:
            u, v = recr(d[imax:],h[imax:])
        else:
            u = d[imax:]
            v = h[imax:]

        return(u,v)
        #if min(er)&lt;0:
    #    u,v = rec(d[imax-1:-1],dhl)
    #else:
    #er  = dhr - h[imax-1:-1]

    lmbda = 0.3/fGHz
    u = np.arange(len(height))/(len(height)-1.)
    l = (height[0])*(1-u)+(height[-1])*u
    h = height - l
    if (h&gt;0).any():
        ul, vl = recl(d, height)
        ur, vr = recr(d, height)
        idtx = len(ul)
        idrx = len(h) - len(ur)
        dtx = d[idtx]
        drx = d[-1]-d[idrx]
        htx = h[idtx-1]
        hrx = h[idrx]
        deq = (dtx*hrx)*d[-1]/(drx*htx+dtx*hrx)
        heq = deq*(htx/dtx)
    else:
        heq = -np.min(np.abs(h[1:-1]))
        ieq = np.where(h==heq)[0][0]
        deq = d[ieq]

    nu = heq*np.sqrt((2/lmbda)*(1/deq+1/(d[-1]-deq)))
    w = nu - 0.1
    L = np.maximum(6.9 + 20*np.log10(np.sqrt(w**2+1)+w), 0)
    return(L, deq, heq)</div>

<div class="viewcode-block" id="two_rays_flatearth"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.two_rays_flatearth.html#pylayers.antprop.loss.two_rays_flatearth">[docs]</a>def two_rays_flatearth(fGHz, **kwargs):
    &quot;&quot;&quot;
    Parameters
    ----------

    p0 : transmitter position
        (3 x Np1) array or (2,) array
    p1 : receiver position
        (3 x Np2) array or (2,) array


    OR :

    d : distance between Tx and Rx
        (Np1,)
    ht : Tx height

    hr : Rx height
        (Np1)
    GtdB : float (0) 
        Transmitter Antenna Gain (dB)
    GrdB : float(0)
        Receiver Antenna Gain (dB)
    fGHz : float (2.4)
        frequency (GHz)
    gamma : complex (-1.+0.j)
        Reflexion coeff


    dB : boolean (True)
        return result in d


    Returns
    -------

    P :
        received power





    Examples
    --------
    .. plot::
        :include-source:

        &gt;&gt;&gt; from pylayers.antprop.loss import *
        &gt;&gt;&gt; NPT=10000
        &gt;&gt;&gt; x=np.array([0,0,8])
        &gt;&gt;&gt; x=x.reshape(3,1)
        &gt;&gt;&gt; y = np.ones((3,NPT))
        &gt;&gt;&gt; y[0,:]=0
        &gt;&gt;&gt; y[1,:]=np.arange(NPT)
        &gt;&gt;&gt; y[2,:]=2
        &gt;&gt;&gt; g0=1
        &gt;&gt;&gt; g1=1
        &gt;&gt;&gt; fGHz=2.4
        &gt;&gt;&gt; PL2R=two_rays_flatearth(p0=x,p1=y,fGHz=fGHz,GtdB=g0,GrdB=g1)
        &gt;&gt;&gt; PL1R = PL(fGHz,x,y,2)
        &gt;&gt;&gt; plt.semilogx(PL2R,label=&#39;two-ray model&#39;)
        &gt;&gt;&gt; plt.semilogx(-PL1R[0,:],label=&#39;one slope model&#39;)
        &gt;&gt;&gt; plt.axis([10,NPT,-150,-50])
        &gt;&gt;&gt; plt.title(&#39;Loss 2-rays model vs one slope model&#39;)
        &gt;&gt;&gt; plt.xlabel(&#39;distance (m)&#39;)
        &gt;&gt;&gt; plt.ylabel(&#39;Loss Pr/Pt (dB)&#39;)
        &gt;&gt;&gt; plt.legend()
        &gt;&gt;&gt; plt.show()

        &gt;&gt;&gt; d=np.arange(1,1000)
        &gt;&gt;&gt; PL2Rd = two_rays_flatearth(d=d,ht=np.array([5]),hr=np.array([10]),fGHz=fGHz,GtdB=g0,GrdB=g1)
        &gt;&gt;&gt; plt.semilogx(PL2Rd,label=&#39;two-ray model&#39;)
        &gt;&gt;&gt; plt.semilogx(-PL1R[0,:],label=&#39;one slope model&#39;)
        &gt;&gt;&gt; plt.axis([10,NPT,-150,-50])
        &gt;&gt;&gt; plt.title(&#39;Loss 2-rays model vs one slope model&#39;)
        &gt;&gt;&gt; plt.xlabel(&#39;distance (m)&#39;)
        &gt;&gt;&gt; plt.ylabel(&#39;Loss Pr/Pt (dB)&#39;)
        &gt;&gt;&gt; plt.legend()
        &gt;&gt;&gt; plt.show()




    References
    ----------

    https://en.wikipedia.org/wiki/Two-ray_ground-reflection_model#As_a_case_of_log_distance_path_loss_model
    http://morse.colorado.edu/~tlen5510/text/classwebch3.html#x15-590003.3.3

    &quot;&quot;&quot;


    defaults = { &#39;p0&#39;:np.array((0,0,10)),
                 &#39;p1&#39;:np.array((0,10,10)),
                 &#39;d&#39;:[],
                 &#39;ht&#39;:10,
                 &#39;hr&#39;:10,
                 &#39;GtdB&#39;:0.,
                 &#39;GrdB&#39;:0.,
                 &#39;gamma&#39;: -1.+0.j,
                 &#39;pol&#39;:&#39;v&#39;,
                 &#39;eps&#39; :[],
                 &#39;sig&#39;:0.,
                 &#39;dB&#39;:True
               }

    for k in defaults:
       if k not in kwargs:
           kwargs[k]=defaults[k]

    GtdB=kwargs.pop(&#39;GtdB&#39;)
    GrdB=kwargs.pop(&#39;GrdB&#39;)

    Gt = 10**((1.*GtdB)/10.)
    Gr = 10**((1.*GrdB)/10.)
    gamma=kwargs.pop(&#39;gamma&#39;)
    pol=kwargs.pop(&#39;pol&#39;)
    eps=kwargs.pop(&#39;eps&#39;)
    sig=kwargs.pop(&#39;sig&#39;)


    if kwargs[&#39;d&#39;] == []:
        p0=kwargs[&#39;p0&#39;]
        p1=kwargs[&#39;p1&#39;]
        assert p0.shape[0] == 3, &#39;p0 is not 3D&#39;
        assert p1.shape[0] == 3, &#39;p1 is not 3D&#39;


        if len(p0.shape) == 1:
            p0=p0.reshape(p0.shape[0],1)
        if len(p1.shape) == 1:
            p1=p1.reshape(p1.shape[0],1)

        p0=1.*p0
        p1=1.*p1

        ht = p0[2,:]
        hr = p1[2,:]
        dloss = np.sqrt(np.sum((p0-p1)**2,axis=0)) #l0
    else:

        dloss=kwargs[&#39;d&#39;]
        ht=kwargs[&#39;ht&#39;]
        hr=kwargs[&#39;hr&#39;]
    
    Gt = 10**((1.*Gt)/10.)
    Gr = 10**((1.*Gr)/10.)

    d0 = np.sqrt( dloss**2 - 1.*(ht-hr)**2 ) # d0
    dref = np.sqrt(d0**2+1.*(ht+hr)**2) #l0&#39;


    if eps != []:
        psy = np.arcsin((ht+hr)/dref)
        er = eps - 60.j*sig*0.3/fGHz
        if pol == &#39;v&#39;:
            Z = (1./er)* np.sqrt(er-np.cos(psy)**2)
        elif pol == &#39;h&#39;:
            Z = np.sqrt(er-np.cos(psy)**2)

        gamma = (np.sin(psy)-Z)/((np.sin(psy)+Z))



    deltad = dref-dloss
    deltaphi = (2*np.pi*fGHz*deltad)/0.3
    E= (0.3/(4*np.pi*fGHz)) * (np.sqrt(Gt*Gr)/dloss + gamma * np.sqrt(Gr*Gr)*(np.exp(-1.j*deltaphi))/dref)
    P = abs(E)**2

    # import ipdb
    # ipdb.set_trace()
    if kwargs[&#39;dB&#39;] :
        return 10*np.log10(P)
    else:
        return P</div>

<div class="viewcode-block" id="lossref_compute"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.lossref_compute.html#pylayers.antprop.loss.lossref_compute">[docs]</a>def lossref_compute(P,h0,h1,k=4/3.) :
    &quot;&quot;&quot;
    compute loss and reflection rays on curved earth

    Parameters
    ----------

    P : float |list

        if len(P) == 1 =&gt; P is a distance
        if len(P) == 4 =&gt; P is a list of [lon0,lat0,lon1,lat1]

        where :
        lat0 : float |string
            latitude first point (decimal |deg min sec Direction)
        lat1 : float |string
            latitude second point (decimal |deg min sec Direction)
        lon0 : float |string
            longitude first point (decimal |deg min sec Direction)
        lon1 : float |string
            longitude second point (decimal |deg min sec Direction)
    h0 : float:
        height of 1st point
    h1 : float:
        height of 2nd point
    k : electromagnetic earth factor


    Returns
    -------

    dloss : float
        length of direct path (meter)
    dref : float
        length of reflective path (meter)
    psy : float
        Reflection angle

    References
    ----------
    B. R. Mahafza, Radar systems analysis and design using MATLAB, Third edition. Boca Raton; London: CRC/Taylor &amp; Francis, chapter 8, 2013.

    &quot;&quot;&quot;


    if isinstance(P,float) or isinstance(P,int) :
        #P is a distance
        r=P
        mode = &#39;dist&#39;
    elif isinstance(P,np.ndarray) or isinstance(P,list):
        if len(P) == 1:
            #P is a distance
            r=P
            mode = &#39;dist&#39;
        elif len(P) == 4:
            #P is a lonlat
            lat0=P[0]
            lon0=P[1]
            lat1=P[2]
            lon1=P[2]
            mode = &#39;lonlat&#39;
        else :
            raise AttributeError(&#39;P must be a list [lat0,lon0,lat1,lon0] or a distance&#39;)
    else :
        raise AttributeError(&#39;Invalid P format ( list |ndarray )&#39;)


    # if h0&lt;h1:
    #     h1,h0 = h0,h1

    r0 = 6371.e3 # earth radius
    re = k*r0 # telecom earth radius


    if mode == &#39;lonlat&#39;:
        # r = distance curvilignenp.arcsin((h1/R1)-R1/(2.*re)) entre TXetRX / geodesic
        r = gu.distance_on_earth(lat0, lon0, lat1, lon1)
    else :
        r=P

    r=1.*r

    # import ipdb
    # ipdb.set_trace()
    p = 2/(np.sqrt(3))*np.sqrt(re*(h0+h1)+(r**2/4.)) #eq 8.45
    eps = np.arcsin(2*re*r*(h1-h0)/p**3) # eq 8.46



    #distance of reflection on curved earth
    r1 = r/2 - p*np.sin(eps/3) #eq 8.44

    r2 = r -r1

    phi1 = r1/re #8.47
    phi2 = r2/re # 8.48

    R1 = np.sqrt(h0**2+4*re*(re+h0)*(np.sin(phi1/2))**2) # 8.51
    R2 = np.sqrt(h1**2+4*re*(re+h1)*(np.sin(phi2/2))**2) #8.52

    Rd = np.sqrt((h1-h0)**2+4*(re+h1)*(re+h0)*np.sin((phi1+phi2)/2.)**2) # 8.53
    # tangente angle on earth
    psy = np.arcsin((h1/R1)-R1/(2.*re)) #eq 8.55
    deltaR = 4*R1*R2*np.sin(psy)**2/(R1+R2+Rd)

    dloss = Rd
    dref = R1+R2

    return psy,dloss,dref</div>

<div class="viewcode-block" id="two_rays_curvedearthold"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.two_rays_curvedearthold.html#pylayers.antprop.loss.two_rays_curvedearthold">[docs]</a>def two_rays_curvedearthold(P,h0,h1,fGHz=2.4,**kwargs):
    &quot;&quot;&quot;


    Parameters
    ----------

    P : float |list

        if len(P) == 1 =&gt; P is a distance
        if len(P) == 4 =&gt; P is a list of [lon0,lat0,lon1,lat1]

        where :
        lat0 : float |string
            latitude first point (decimal |deg min sec Direction)
        lat1 : float |string
            latitude second point (decimal |deg min sec Direction)
        lon0 : float |string
            longitude first point (decimal |deg min sec Direction)
        lon1 : float |string
            longitude second point (decimal |deg min sec Direction)
    h0 : float:
        height of 1st point
    h1 : float:
        height of 2nd point
    fGHz : float
        frequency (GHz)


    k : float
        electromagnetic earth factor
    GtdB : float
        Transmitter Antenna Gain (dB)
    GrdB : float
        Receiver Antenna Gain (dB)
    gamma : complex (-1.+0.j)
        Reflexion coeff if eps and sig are not precised

    &#39;pol&#39;: string (&#39;v&#39;)
        polarization (&#39;v&#39;|&#39;h&#39;)
    &#39;eps&#39; : float ([])
        lossless relative permittivity [],
    &#39;sig&#39;: float (0.)
        conductivity


    dB : boolean (True)
        return result in dB


    Returns
    -------

    P :
        received power

    Examples
    --------

    .. plot::
        :include-source:

        &gt;&gt;&gt; from pylayers.antprop.loss import *
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; fGHz=2.4
        &gt;&gt;&gt; p0=np.array(([0,0,20]))
        &gt;&gt;&gt; p1=np.array(([0,1,20]))
        &gt;&gt;&gt; p0=p0.reshape(3,1)
        &gt;&gt;&gt; p1=p1.reshape(3,1)
        &gt;&gt;&gt; TRF = [] #Two Ray model on flat earth
        &gt;&gt;&gt; TRC = [] #Two Ray model on curved earth
        &gt;&gt;&gt; PLoss=[]
        &gt;&gt;&gt; for d in np.arange(1,10000,1):
        &gt;&gt;&gt;     p1[1,:]=d
        &gt;&gt;&gt;     TRF.append(two_rays_flatearth(p0[:,0],p1[:,0],fGHz,GtdB=0.,GrdB=0.,))
        &gt;&gt;&gt;     TRC.append(two_rays_curvedearth(d,p0[2,:],p1[2,:],fGHz))
        &gt;&gt;&gt;     PLoss.append(PL(fGHz, p0[:,0],p1[:,0], n=2.0, dB=True, d0=np.array([1])))
        &gt;&gt;&gt; PLoss=np.array(PLoss)[:,0,0]
        &gt;&gt;&gt; plt.semilogx(TRF,label=&#39;two-rays model flat earth&#39;)
        &gt;&gt;&gt; plt.semilogx(TRC,label=&#39;two-rays model curved earth&#39;)
        &gt;&gt;&gt; plt.semilogx(-PLoss,label=&#39;Path Loss&#39;)
        &gt;&gt;&gt; plt.legend()
        &gt;&gt;&gt; plt.show()

    &quot;&quot;&quot;


    defaults = { &#39;GtdB&#39;:0.,
                 &#39;GrdB&#39;:0.,
                 &#39;k&#39;:4/3.,
                 &#39;gamma&#39;: -1.+0.j,
                 &#39;pol&#39;:&#39;v&#39;,
                 &#39;eps&#39; :[],
                 &#39;sig&#39;:0.,
                 &#39;mode&#39;:&#39;PL&#39;,
                 &#39;dB&#39;:True
               }

    for k in defaults:
        if k not in kwargs:
            kwargs[k]=defaults[k]

    GtdB=kwargs.pop(&#39;GtdB&#39;)
    GrdB=kwargs.pop(&#39;GrdB&#39;)

    Gt = 10**((1.*GtdB)/10.)
    Gr = 10**((1.*GrdB)/10.)
    k=kwargs.pop(&#39;k&#39;)
    gamma=kwargs.pop(&#39;gamma&#39;)
    pol=kwargs.pop(&#39;pol&#39;)
    eps=kwargs.pop(&#39;eps&#39;)
    sig=kwargs.pop(&#39;sig&#39;)


    h0=1.*h0
    h1=1.*h1

    psy,dloss,dref = lossref_compute(P,h0,h1,k)

    if eps != []:
        er = eps  - 60.j*sig*0.3/fGHz
        if pol == &#39;v&#39;:
            Z= (1./er)* np.sqrt(er-np.cos(psy)**2)
        elif pol == &#39;h&#39;:
            Z= np.sqrt(er-np.cos(psy)**2)

        gamma = (np.sin(psy)-Z)/((np.sin(psy)+Z))

    deltad= dref-dloss
    deltaphi = (2*np.pi*fGHz*deltad)/0.3
    E= (0.3/(4*np.pi*fGHz) ) *(np.sqrt(Gt*Gr)/dloss + gamma * np.sqrt(Gr*Gr)*(np.exp(-1.j*deltaphi))/dref)
    P = abs(E)**2

    # import ipdb
    # ipdb.set_trace()
    if kwargs[&#39;dB&#39;] :
        return 10*np.log10(P)
    else:
        return P</div>


<div class="viewcode-block" id="visuPts"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.visuPts.html#pylayers.antprop.loss.visuPts">[docs]</a>def visuPts(S,nu,nd,Pts,Values,fig=[],sp=[],vmin=0,vmax=-1,label=&#39; &#39;,tit=&#39;&#39;,size=25,colbar=True,xticks=False):
    &quot;&quot;&quot; visuPt  : Visualization of values a given points

    Parameters
    ----------

    S       : Simul
    nu      : useful Points
    nd      : Points deleted
    Pts     : Points coordinates
    Value
    &quot;&quot;&quot;

    vx  = Pts[nu,0]
    vy  = Pts[nu,1]
    vxd = Pts[nd,0]
    vyd = Pts[nd,1]

    if vmax&lt;vmin:
        #vmin = min(Values)
        vmin = -150
        vmax = max(Values)
    S.L.showGs()
    if xticks:
        for loc, spine in sp.spines.iteritems():
              if loc in [&#39;left&#39;,&#39;bottom&#39;]:
                spine.set_position((&#39;outward&#39;,10)) # outward by 10 points
                sp.yaxis.set_ticks_position(&#39;left&#39;)
                sp.xaxis.set_ticks_position(&#39;bottom&#39;)
              elif loc in [&#39;right&#39;,&#39;top&#39;]:
                 spine.set_color(&#39;none&#39;) # don&#39;t draw spine
              else:
                raise ValueError(&#39;unknown spine location: %s&#39;%loc)
    else:
        for loc, spine in sp.spines.iteritems():
              if loc in [&#39;left&#39;]:
                spine.set_position((&#39;outward&#39;,10)) # outward by 10 points
                sp.yaxis.set_ticks_position(&#39;left&#39;)
              elif loc in [&#39;right&#39;,&#39;top&#39;,&#39;bottom&#39;]:
                 spine.set_color(&#39;none&#39;) # don&#39;t draw spine
                 sp.xaxis.set_ticks([])
              else:
                raise ValueError(&#39;unknown spine location: %s&#39;%loc)



        # no xaxis ticks
        #ax.xaxis.set_ticks([])
    #sp.spines[&#39;left&#39;].set_position(&#39;center&#39;)
        #sp.spines[&#39;left&#39;].set_color(&#39;none&#39;)
    #sp.spines[&#39;right&#39;].set_position(&#39;center&#39;)
        #sp.spines[&#39;right&#39;].set_color(&#39;none&#39;)
    #sp.spines[&#39;bottom&#39;].set_position(&#39;center&#39;)
    #sp.xaxis.set_ticks_position(&#39;bottom&#39;)
    #sp.yaxis.set_ticks_position(&#39;left&#39;)
        #sp.spines[&#39;bottom&#39;].set_color(&#39;none&#39;)
    #sp.spines[&#39;top&#39;].set_position(&#39;center&#39;)
        #sp.spines[&#39;top&#39;].set_color(&#39;none&#39;)
    #
    # Rooms annotation
    #
    annotate(&#39;R 8&#39;,xy=(-19,14.1))
    annotate(&#39;R 9&#39;,xy=(-24.5,6.5))
    annotate(&#39;R 14&#39;,xy=(-20,6.5))
    annotate(&#39;R 10&#39;,xy=(-16.5,6.5))
    annotate(&#39;R 7&#39;,xy=(-10.5,14.1))
    annotate(&#39;R 11&#39;,xy=(-2.5,13.5))
    annotate(&#39;R 12&#39;,xy=(-8.7,6.5))
    annotate(&#39;R 13&#39;,xy=(-5.2,14.5))
    annotate(&#39;R 1&#39;,xy=(3.5,8))
    annotate(&#39;R 2&#39;,xy=(1.5,13.8))
    annotate(&#39;R 6&#39;,xy=(-3.6,6.5))


    n=scatter(vx,vy,marker=&#39;o&#39;,c=Values,s=size,vmin=vmin,vmax=vmax)
    n.set_edgecolor(&#39;face&#39;)
#    m=scatter(vxd,vyd,marker=&#39;o&#39;,c=&#39;k&#39;,s=size)
#    m.set_edgecolor(&#39;face&#39;)
    axis(&#39;scaled&#39;)
    title(tit)
    ylabel(&#39;meters&#39;)
    if xticks:
        xlabel(&#39;meters&#39;)
    if colbar:
        cbar=colorbar(orientation=&#39;vertical&#39;)
        cbar.set_label(label)</div>

<div class="viewcode-block" id="cdf"><a class="viewcode-back" href="../../../api/pylayers.antprop.loss.cdf.html#pylayers.antprop.loss.cdf">[docs]</a>def cdf(x,colsym=&quot;&quot;,lab=&quot;&quot;,lw=4):
    &quot;&quot;&quot; plot the cumulative density function

    Parameters
    ----------

    x : np.array()
    colsym : string
    lab : string
    lw : int
        linewidth

    Examples
    --------

    .. plot::
        :include-source:

        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import matplotlib.pyplot as plt 
        &gt;&gt;&gt; x = np.random.randn(10000)
        &gt;&gt;&gt; cdf(x)
        &gt;&gt;&gt; plt.show()

    &quot;&quot;&quot;
    rcParams[&#39;legend.fontsize&#39;]=20
    rcParams[&#39;font.size&#39;]=20

    x  = np.sort(x)
    n  = len(x)
    x2 = np.repeat(x, 2)
    y2 = np.hstack([0.0, repeat(np.arange(1,n) / float(n), 2), 1.0])
    plt.plot(x2,y2,colsym,label=lab,linewidth=lw)
    plt.grid(&#39;on&#39;)
    plt.legend(loc=2)
    plt.xlabel(&#39;Ranging Error[m]&#39;)
    plt.ylabel(&#39;Cumulative Probability&#39;)</div>

if __name__==&quot;__main__&quot;:
    doctest.testmod()
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, PyLayers developer team.
      Last updated on Oct 17, 2018.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>