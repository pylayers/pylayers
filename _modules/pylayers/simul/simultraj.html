

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pylayers.simul.simultraj &mdash; PyLayers</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Python
          

          
            
            <img src="../../../_static/pylayers.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebook/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout1.html">Loading an outdoor layout from its address</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_antenna.html">Antenna Pattern for an H plane sectoral antenna &#64; 32GHz</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLayout2.html">Building graphs of a Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_coverage.html">Indoor Radio Coverage with Motley Keenan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_layout.html">8 Random Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exAbsGas.html">Attenuation due to atmospheric gases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exDLink.html">Evaluation of a radio link DLink</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_w1.html">Indoor Radio Coverage FP7 WHERE1 M1 setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_exLuebbers.html">UWB Ray tracing simulation  in outdoor scenario</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction_polar.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/plot_diffraction.html">Diffraction coefficient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html">1&nbsp;&nbsp;&nbsp;pylayers.util.project Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.layout">2&nbsp;&nbsp;&nbsp;pylayers.gis.layout Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.selectl">3&nbsp;&nbsp;&nbsp;pylayers.gis.selectl Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.srtm">4&nbsp;&nbsp;&nbsp;pylayers.gis.srtm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.osmparser">5&nbsp;&nbsp;&nbsp;pylayers.gis.osmparser Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.gis.ezone">6&nbsp;&nbsp;&nbsp;pylayers.gis.ezone Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antenna">7&nbsp;&nbsp;&nbsp;pylayers.antprop.antenna Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.aarray">8&nbsp;&nbsp;&nbsp;pylayers.antprop.aarray Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.spharm">9&nbsp;&nbsp;&nbsp;pylayers.antprop.spharm Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antssh">10&nbsp;&nbsp;&nbsp;pylayers.antprop.antssh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.antvsh">11&nbsp;&nbsp;&nbsp;pylayers.antprop.antvsh Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.slab">12&nbsp;&nbsp;&nbsp;pylayers.antprop.slab Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.signature">13&nbsp;&nbsp;&nbsp;pylayers.antprop.signature Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.interactions">14&nbsp;&nbsp;&nbsp;pylayers.antprop.interactions Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffraction">15&nbsp;&nbsp;&nbsp;pylayers.antprop.diffraction Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.diffRT">16&nbsp;&nbsp;&nbsp;pylayers.antprop.diffRT Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.rays">17&nbsp;&nbsp;&nbsp;pylayers.antprop.rays Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.loss">18&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.channel">19&nbsp;&nbsp;&nbsp;pylayers.antprop.channel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id39">20&nbsp;&nbsp;&nbsp;pylayers.antprop.loss Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coverage">21&nbsp;&nbsp;&nbsp;pylayers.antprop.coverage Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.antprop.coeffModel">22&nbsp;&nbsp;&nbsp;pylayers.antprop.coeffModel Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.link">23&nbsp;&nbsp;&nbsp;pylayers.simul.link Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit">24&nbsp;&nbsp;&nbsp;pylayers.simul.exploit Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.exploit_simulnet">25&nbsp;&nbsp;&nbsp;pylayers.simul.exploit_simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simulnet">26&nbsp;&nbsp;&nbsp;pylayers.simul.simulnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.simul.simultraj">27&nbsp;&nbsp;&nbsp;pylayers.simul.simultraj Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.exploit.simnet">28&nbsp;&nbsp;&nbsp;pylayers.exploit.simnet Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesuwb">29&nbsp;&nbsp;&nbsp;pylayers.measures.mesuwb Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.mesmimo">30&nbsp;&nbsp;&nbsp;pylayers.measures.mesmimo Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.cormoran">31&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.vna.E5072A">32&nbsp;&nbsp;&nbsp;pylayers.measures.vna.E5072A Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.measures.parker.smparker">33&nbsp;&nbsp;&nbsp;pylayers.measures.parker.smparker Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.bsignal">34&nbsp;&nbsp;&nbsp;pylayers.signal.bsignal Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.standard">35&nbsp;&nbsp;&nbsp;pylayers.signal.standard Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.device">36&nbsp;&nbsp;&nbsp;pylayers.signal.device Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.DF">37&nbsp;&nbsp;&nbsp;pylayers.signal.DF Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.signal.waveform">38&nbsp;&nbsp;&nbsp;pylayers.signal.waveform Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.agent">39&nbsp;&nbsp;&nbsp;pylayers.mobility.agent Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#module-pylayers.mobility.ban.body">40&nbsp;&nbsp;&nbsp;pylayers.mobility.ban.body Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/references.html#id138">41&nbsp;&nbsp;&nbsp;pylayers.measures.cormoran Module</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pylayers.simul.simultraj</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pylayers.simul.simultraj</h1><div class="highlight"><pre>
<span></span>#!/usr/bin/python
# -*- coding: utf-8 -*-
#
&quot;&quot;&quot;
.. currentmodule:: pylayers.simul.simultraj

.. autosummary::

&quot;&quot;&quot;
import doctest
import numpy as np
import copy
import matplotlib.pylab as plt
import pylayers.util.pyutil as pyu
import pylayers.signal.waveform as wvf
from pylayers.signal.device import Device

# Handle Layout
from pylayers.gis.layout import Layout
# Handle VectChannel and ScalChannel
from pylayers.antprop import antenna
from pylayers.network.network import Network
from pylayers.simul.link import *
from pylayers.measures.cormoran import *

# Handle directory hierarchy
from pylayers.util.project import *
# Handle UWB measurements
import pylayers.mobility.trajectory as tr
from pylayers.mobility.ban.body import *
from pylayers.antprop.statModel import *
import pandas as pd
import csv

<div class="viewcode-block" id="Simul"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul">[docs]</a>class Simul(PyLayers):
    &quot;&quot;&quot;
    Link oriented simulation

    A simulation requires :

        + A Layout
        + A Person
        + A Trajectory

    or a CorSer instance

    Members
    -------

    dpersons : dictionnary of persons (agent)
    dap : dictionnary of access points

    Methods
    -------

    load_simul : load configuration file
    load_Corser : load a Corser file
    _gen_net : generate network and asociated links
    show : show layout and network
    evaldeter : run simulation over time


    &quot;&quot;&quot;

    def __init__(self, source =&#39;simulnet_TA-Office.h5&#39;,verbose=False):
        &quot;&quot;&quot; object constructor

        Parameters
        ----------

        source : string
            h5 trajectory file default simulnet_TA-Office.h5

        verbose : boolean

        Notes
        -----

        The simultraj has a dataframe


        &quot;&quot;&quot;


        # self.progress = -1  # simulation not loaded
        self.verbose = verbose
        self.cfield = []
        self.dpersons = {}

        self.dap = {}
        self.Nag = 0
        self.Nap = 0

        # source analysis
        if isinstance(source,str):
            self.filetraj = source
            self.load_simul(source)
            self.source = &#39;simul&#39;
        elif &#39;pylayers&#39; in source.__module__:
            self.filetraj = source._filename
            self.load_CorSer(source)
            cutoff=2
            self.source = &#39;CorSer&#39;


        # generate the Network
        # The wireless standard and frequency is fixed in this function
        #
        self._gen_net()
        # initialize Stochastic Link
        self.SL = SLink()
        # initialize Deterministic Link
        self.DL = DLink(L=self.L,verbose=self.verbose)
        self.DL.cutoff=cutoff

        self.filename = &#39;simultraj_&#39; + self.filetraj + &#39;.h5&#39;

        # data is a panda container which is initialized 
        #
        # We do not save all the simulation in a DataFRame anymore
        #
        #self.data = pd.DataFrame(columns=[&#39;id_a&#39;, &#39;id_b&#39;,
        #                                  &#39;x_a&#39;, &#39;y_a&#39;, &#39;z_a&#39;,
        #                                  &#39;x_b&#39;, &#39;y_b&#39;, &#39;z_b&#39;,
        #                                  &#39;d&#39;, &#39;eng&#39;, &#39;typ&#39;,
        #                                  &#39;wstd&#39;, &#39;fcghz&#39;,
        #                                  &#39;fbminghz&#39;, &#39;fbmaxghz&#39;, &#39;fstep&#39;, &#39;aktk_id&#39;,
        #                                  &#39;sig_id&#39;, &#39;ray_id&#39;, &#39;Ct_id&#39;, &#39;H_id&#39;
        #                                  ])

        #self.data.index.name=&#39;t&#39;
        self._filecsv = self.filename.split(&#39;.&#39;)[0] + &#39;.csv&#39;
        self.todo = {&#39;OB&#39;: True,
                    &#39;B2B&#39;: True,
                    &#39;B2I&#39;: True,
                    &#39;I2I&#39;: False}

        filenameh5 = pyu.getlong(self.filename,pstruc[&#39;DIRLNK&#39;])

        if os.path.exists(filenameh5) :
            self.loadpd()
        self.settime(0.)
        # self._saveh5_init()


    def __repr__(self):


        s = &#39;Simul trajectories class\n&#39;
        s = s + &#39;------------------------\n&#39;
        s = s +&#39;\n&#39;
        s = s + &#39;Used layout: &#39; + self.L.filename + &#39;\n&#39;
        s = s + &#39;Number of Agents: &#39; + str(self.Nag) + &#39;\n&#39;
        s = s + &#39;Number of Access Points: &#39; + str(self.Nap) + &#39;\n&#39;
        s = s + &#39;Link to be evaluated: &#39; + str(self.todo) + &#39;\n&#39;
        s = s + &#39;tmin: &#39; + str(self._tmin) + &#39;\n&#39;
        s = s + &#39;tmax: &#39; + str(self._tmax) + &#39;\n&#39;
        s = s +&#39;\n&#39;
        # network info
        s = s + &#39;self.N :\n&#39;
        s = s + self.N.__repr__() + &#39;\n&#39;
        s = s + &#39;CURRENT TIME: &#39; + str(self.ctime) + &#39;\n&#39;




        return s

<div class="viewcode-block" id="Simul.load_simul"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.load_simul">[docs]</a>    def load_simul(self, source):
        &quot;&quot;&quot;  load a simultraj configuration file

        Parameters
        ----------

        source : string
            name of simulation file to be loaded

        &quot;&quot;&quot;
        self.filetraj = source
        if not os.path.isfile(source):
            raise AttributeError(&#39;Trajectory file&#39;+source+&#39;has not been found.\
             Please make sure you have run a simulnet simulation before runining simultraj.&#39;)

        # get the trajectory
        traj = tr.Trajectories()
        traj.loadh5(self.filetraj)

        # get the layout
        self.L = Layout(traj.Lfilename)

        # resample trajectory
        for ut, t in enumerate(traj):
            if t.typ == &#39;ag&#39;:
                person = Body(t.name + &#39;.ini&#39;)
                tt = t.time()
                self.dpersons.update({t.name: person})
                self._tmin = tt[0]
                self._tmax = tt[-1]
                self.time = tt
            else:
                pos = np.array([t.x[0], t.y[0], t.z[0]])
                self.dap.update({t.ID: {&#39;pos&#39;: pos,
                                        &#39;ant&#39;: antenna.Antenna(),
                                        &#39;name&#39;: t.name
                                        }
                                 })
        self.ctime = np.nan
        self.Nag = len(self.dpersons.keys())
        self.Nap = len(self.dap.keys())
        self.traj = traj</div>

<div class="viewcode-block" id="Simul.load_CorSer"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.load_CorSer">[docs]</a>    def load_CorSer(self,source):
        &quot;&quot;&quot; load CorSer file for simulation

        Parameters
        ----------

        source :
            name of simulation file to be loaded

        &quot;&quot;&quot;

        if isinstance(source.B,Body):
            B = [source.B]
        elif isinstance(source.B,list):
            B = source.B
        elif isinstance(source.B,dict):
            B=source.B.values()
        else:
            raise AttributeError(&#39;CorSer.B must be a list or a Body&#39;)
        self.L = source.L
        self.traj = tr.Trajectories()
        self.traj.Lfilename=self.L._filename

        for b in B:
            self.dpersons.update({b.name: b})
            self._tmin = b.time[0]
            self._tmax = b.time[-1]
            self.time = b.time
            self.traj.append(b.traj)

        for ap in source.din:
            techno,ID=ap.split(&#39;:&#39;)
            if techno == &#39;HKB&#39;:
                techno = &#39;hikob&#39;
            if techno == &#39;TCR&#39;:
                techno = &#39;tcr&#39;
            if techno == &#39;BS&#39;:
                techno = &#39;bespoon&#39;


            self.dap.update({ap: {&#39;pos&#39;: source.din[ap][&#39;p&#39;],
                                  &#39;ant&#39;: source.din[ap][&#39;ant&#39;],
                                  &#39;T&#39;: source.din[ap][&#39;T&#39;],
                                  &#39;name&#39;: techno
                                        }
                                 })
        self.ctime = np.nan
        self.Nag = len(B)
        self.Nap = len(source.din)
        self.corser = source</div>

    def _gen_net(self):
        &quot;&quot;&quot; generate Network and associated links

        Notes
        -----

        Create self.N : Network object

        See Also
        --------

        pylayers.network.network

        &quot;&quot;&quot;

        #
        # Create Network
        #
        N = Network()
        #
        # get devices on bodies
        #
        # forall person
        #   forall device
        for p in self.dpersons:
            D = []
            for dev in self.dpersons[p].dev:
                aDev = Device(self.dpersons[p].dev[dev][&#39;name&#39;], ID = dev)
                D.append(aDev)

                D[-1].ant[&#39;A1&#39;][&#39;name&#39;] = self.dpersons[p].dev[dev][&#39;file&#39;]
                D[-1].ant[&#39;antenna&#39;] = self.dpersons[p].dev[dev][&#39;ant&#39;]
            N.add_devices(D, grp=p)
        #
        # get access point devices
        #
        for ap in self.dap:
            D = Device(self.dap[ap][&#39;name&#39;], ID = ap)
            D.ant[&#39;antenna&#39;] = self.dap[ap][&#39;ant&#39;]
            N.add_devices(D, grp = &#39;ap&#39;, p = self.dap[ap][&#39;pos&#39;])
            N.update_orient(ap, self.dap[ap][&#39;T&#39;], now = 0.)
        # create Network
        #
        #    _get_wstd
        #    _get_grp
        #    _connect
        #    _init_PN
        #
        N.create()
        self.N = N

<div class="viewcode-block" id="Simul.show"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.show">[docs]</a>    def show(self):
        &quot;&quot;&quot; show actual simlulation configuration
        &quot;&quot;&quot;
        fig, ax = self.L.showGs()
        fig, ax = self.N.show(fig=fig, ax=ax)
        return fig, ax</div>

<div class="viewcode-block" id="Simul.evaldeter"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.evaldeter">[docs]</a>    def evaldeter(self, na, nb, wstd, fmod=&#39;force&#39;,nf=10,fGHz=[], **kwargs):
        &quot;&quot;&quot; deterministic evaluation of a link

        Parameters
        ----------

        na : string:
            node a id in self.N (Network)
        nb : string:
            node b id in self.N (Network)
        wstd : string:
            wireless standard used for commmunication between na and nb
        fmode : string (&#39;center&#39;|&#39;band&#39;|&#39;force&#39;)
            mode of frequency evaluation
            center : single frequency (center frequency of a channel)
            band : nf points on the whole band
            force : takes directly fGHz
        nf : int:
            number of frequency points (if fmode = &#39;band&#39;)
        **kwargs : argument of DLink

        Returns
        -------

        (a, t )

        a : ndarray
            alpha_k
        t : ndarray
            tau_k

        See Also
        --------

        pylayers.simul.link.DLink

        &quot;&quot;&quot;

        # todo in network :
        # take into consideration the postion and rotation of antenna and not device

        self.DL.Aa = self.N.node[na][&#39;ant&#39;][&#39;antenna&#39;]
        self.DL.a = self.N.node[na][&#39;p&#39;]
        self.DL.Ta = self.N.node[na][&#39;T&#39;]

        self.DL.Ab = self.N.node[nb][&#39;ant&#39;][&#39;antenna&#39;]
        self.DL.b = self.N.node[nb][&#39;p&#39;]
        self.DL.Tb = self.N.node[nb][&#39;T&#39;]

        #
        # The frequency band is chosen from the selected standard
        #  if fmode == &#39;center&#39;
        #      only center frequency is calculated
        #
        #&#39;
        if fmod == &#39;center&#39;:
            self.DL.fGHz = self.N.node[na][&#39;wstd&#39;][wstd][&#39;fcghz&#39;]
        if fmod == &#39;band&#39;:
            fminGHz = self.N.node[na][&#39;wstd&#39;][wstd][&#39;fbminghz&#39;]
            fmaxGHz = self.N.node[na][&#39;wstd&#39;][wstd][&#39;fbmaxghz&#39;]
            self.DL.fGHz = np.linspace(fminGHz, fmaxGHz, nf)
        if fmod == &#39;force&#39;:
            assert len(fGHz)&gt;0,&quot;fGHz has not been defined&quot;
            self.DL.fGHz = fGHz

        a, t = self.DL.eval(**kwargs)

        return a, t</div>

<div class="viewcode-block" id="Simul.evalstat"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.evalstat">[docs]</a>    def evalstat(self, na, nb):
        &quot;&quot;&quot; statistical evaluation of a link

        Parameters
        ----------

        na : string:
            node a id in self.N (Netwrok)
        nb : string:
            node b id in self.N (Netwrok)

        Returns
        -------

        (a, t, eng)

        a : ndarray
            alpha_k
        t : ndarray
            tau_k
        eng : float
            engagement
        &quot;&quot;&quot;

        pa = self.N.node[na][&#39;p&#39;]
        pb = self.N.node[nb][&#39;p&#39;]
        if self.source == &#39;simul&#39;:
            dida, name = na.split(&#39;_&#39;)
            didb, name = nb.split(&#39;_&#39;)
        elif self.source ==&#39;CorSer&#39;:
            bpa,absolutedida,dida,name,technoa = self.corser.devmapper(na)
            bpb,absolutedidb,didb,name,technob = self.corser.devmapper(nb)

        ak, tk, eng = self.SL.onbody(self.dpersons[name], dida, didb, pa, pb)

        return ak, tk, eng</div>


<div class="viewcode-block" id="Simul.settime"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.settime">[docs]</a>    def settime(self,t):
        &quot;&quot;&quot; set current time
        &quot;&quot;&quot;
        self.ctime = t
        self._traj=copy.copy(self.traj)
        self.update_pos(t)</div>


<div class="viewcode-block" id="Simul.run"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.run">[docs]</a>    def run(self, **kwargs):
        &quot;&quot;&quot; run the link evaluation along a trajectory


        Parameters
        ----------

        OB: boolean
            perform on body statistical link evaluation
        B2B:  boolean
            perform body to body deterministic link evaluation
        B2I: boolean
            perform body to infrastructure deterministic link evaluation
        I2I:  boolean
            perform infrastructure to infrastructure deterministic link eval.
        links: dict
            dictionnary of link to be evaluated (key is wtsd and value is a list of links)
            (if [], all link are considered)
        wstd: list
            list of wstd to be evaluated
            (if [], all wstd are considered)
        t: np.array
            list of timestamp to be evaluated
            (if [], all timestamps are considered)
        tbr : boolean
            time in bit reverse order (tmin,tmax,N) Npoints=2**N
        replace_data: boolean (True)
            if True , reference id of all already simulated link will be erased
                and replace by new simulation id

        fGHz : np.array
            frequency in GHz


        Examples
        --------

        &gt;&gt;&gt; from pylayers.simul.simultraj import *
        &gt;&gt;&gt; from pylayers.measures.cormoran import *
        &gt;&gt;&gt; C=CorSer(layout=True)
        &gt;&gt;&gt; S=Simul(C,verbose=True)
        &gt;&gt;&gt; link={&#39;ieee802154&#39;:[]}
        &gt;&gt;&gt; link[&#39;ieee802154&#39;].append(S.N.links[&#39;ieee802154&#39;][0])
        &gt;&gt;&gt; lt = [0,0.2,0.3,0.4,0.5]
        &gt;&gt;&gt; S.run(links=link,t=lt)


        &quot;&quot;&quot;
        defaults = {&#39;OB&#39;: True,
                    &#39;B2B&#39;: True,
                    &#39;B2I&#39;: True,
                    &#39;I2I&#39;: False,
                    &#39;links&#39;: {},
                    &#39;wstd&#39;: [],
                    &#39;t&#39;: np.array([]),
                    &#39;btr&#39;:True,
                    &#39;DLkwargs&#39;:{},
                    &#39;replace_data&#39;:True,
                    &#39;fmod&#39;:&#39;force&#39;,
                    &#39;fGHz&#39;:np.array([2.45])
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]

        DLkwargs = kwargs.pop(&#39;DLkwargs&#39;)
        links = kwargs.pop(&#39;links&#39;)
        wstd = kwargs.pop(&#39;wstd&#39;)
        OB = kwargs.pop(&#39;OB&#39;)
        B2B = kwargs.pop(&#39;B2B&#39;)
        B2I = kwargs.pop(&#39;B2I&#39;)
        I2I = kwargs.pop(&#39;I2I&#39;)
        fmod = kwargs.pop(&#39;fmod&#39;)
        self.fGHz = kwargs.pop(&#39;fGHz&#39;)

        self.todo.update({&#39;OB&#39;:OB,&#39;B2B&#39;:B2B,&#39;B2I&#39;:B2I,&#39;I2I&#39;:I2I})


        # Check link attribute

        if links == {}:
            links = self.N.links
        elif not isinstance(links, dict):
            raise AttributeError(&#39;links is {wstd:[list of links]}, see self.N.links&#39;)

        for k in links.keys():
            checkl = [l in self.N.links[k] for l in links[k]]
            if len(np.where(checkl==False)[0])&gt;0:
            # if sum(checkl) != len(self.N.links):
                uwrong = np.where(np.array(checkl) is False)[0]
                raise AttributeError(str(np.array(links)[uwrong])
                                     + &#39; links does not exist in Network&#39;)

        wstd = links.keys()
        # # Check wstd attribute
        # if wstd == []:
        #     wstd = self.N.wstd.keys()
        # elif not isinstance(wstd, list):
        #     wstd = [wstd]

        checkw = [w in self.N.wstd.keys() for w in wstd]
        if sum(checkw) != len(wstd):
            uwrong = np.where(np.array(checkw) is False)[0]
            raise AttributeError(str(np.array(wstd)[uwrong])
                                 + &#39; wstd are not in Network&#39;)

        # force time attribute compliant

        if not isinstance(kwargs[&#39;t&#39;],np.ndarray):
            if isinstance(kwargs[&#39;t&#39;],list):
                lt = np.array(kwargs[&#39;t&#39;])
            elif (isinstance(kwargs[&#39;t&#39;], int)
                 or isinstance(kwargs[&#39;t&#39;],float)):
                lt = np.array([kwargs[&#39;t&#39;]])
        else :
            lt = kwargs[&#39;t&#39;]

        #if len(lt) == 0:
        #    lt = self.time
        # check time attribute
        if kwargs[&#39;btr&#39;]:
            if (lt[0] &lt; self._tmin) or\
               (lt[1] &gt; self._tmax) :
                raise AttributeError(&#39;Requested time range not available&#39;)

        # self._traj is a copy of self.traj, which is affected by resampling.
        # it is only a temporary attribute for a given run
        # if len(lt) &gt; 1:
        #     sf = 1/(1.*lt[1]-lt[0])
        #     self._traj = self.traj.resample(sf=sf, tstart=lt[0])

        # else:
        #     self._traj = self.traj.resample(sf=1.0, tstart=lt[0])
        #     self._traj.time()
        # self.time = self._traj.t
        # self._time = pd.to_datetime(self.time,unit=&#39;s&#39;)
        #
        # Nested Loops
        #
        #  time
        #    standard
        #      links
        #           evaldeter &amp;| evalstat
        #
        #lt = self.get_sim_time(lt)
        #self._time=self.get_sim_time(lt)

        init = True
        if kwargs[&#39;btr&#39;]:
            tmin = lt[0]
            tmax = lt[1]
            Nt   = int(2**lt[2])
            ta   = np.linspace(tmin,tmax,Nt)
            it   = np.hstack((np.r_[0],np.r_[pyu.bitreverse(Nt,int(lt[2]))]))
            #trev = t[it]
        else:
            ta = kwargs[&#39;t&#39;]
            it = range(len(ta))

        ## Start to loop over time
        ##   ut : counter
        ##   t  : time value (s)
        #for ut, t in enumerate(lt):
        for ks,ut in enumerate(it):
            t  = ta[ut]
            self.ctime = t
            # update spatial configuration of the scene for time t
            self.update_pos(t)
            # print self.N.__repr__()
            ## Start to loop over available Wireless standard
            ##
            for w in wstd:
                ## Start to loop over the chosen links stored in links
                ##
                for na, nb, typ in links[w]:
                    # If type of link is valid (Body 2 Body,...)
                    #
                    if self.todo[typ]:
                        if self.verbose:
                            print(&#39;-&#39;*30)
                            print(&#39;time:&#39;, t, &#39;/&#39;,  lt[-1] ,&#39; time idx:&#39;, ut, &#39;/&#39;,len(ta),&#39;/&#39;,ks)
                            print(&#39;processing: &#39;,na, &#39; &lt;-&gt; &#39;, nb, &#39;wstd: &#39;, w)
                            print(&#39;-&#39;*30)
                        eng = 0
                        #
                        # Invoque link deterministic simulation 
                        #
                        #  node : na
                        #  node : nb
                        #  wstd : w
                        #
                        self.evaldeter(na, nb,
                                       w,
                                       applywav=False,
                                       fmod = fmod,
                                       fGHz = self.fGHz,
                                       **DLkwargs)
                        # if typ == &#39;OB&#39;:
                        #     self.evalstat(na, nb)
                        #     eng = self.SL.eng
                        #     L = self.DL + self.SL
                        #     self._ak = L.H.ak
                        #     self._tk = L.H.tk
                        # else :

                        # Get alphak an tauk
                        self._ak = self.DL.H.ak
                        self._tk = self.DL.H.tk
                        aktk_id = str(ut) + &#39;_&#39; + na + &#39;_&#39; + nb + &#39;_&#39; + w
                        # this is a dangerous way to proceed ! 
                        # the id as a finite number of characters
                        while len(aktk_id)&lt;40:
                            aktk_id = aktk_id + &#39; &#39;
                        df = pd.DataFrame({ &#39;id_a&#39;: na,
                                    &#39;id_b&#39;: nb,
                                    &#39;x_a&#39;: self.N.node[na][&#39;p&#39;][0],
                                    &#39;y_a&#39;: self.N.node[na][&#39;p&#39;][1],
                                    &#39;z_a&#39;: self.N.node[na][&#39;p&#39;][2],
                                    &#39;x_b&#39;: self.N.node[nb][&#39;p&#39;][0],
                                    &#39;y_b&#39;: self.N.node[nb][&#39;p&#39;][1],
                                    &#39;z_b&#39;: self.N.node[nb][&#39;p&#39;][2],
                                    &#39;d&#39;: self.N.edge[na][nb][&#39;d&#39;],
                                    &#39;eng&#39;: eng,
                                    &#39;typ&#39;: typ,
                                    &#39;wstd&#39;: w,
                                    &#39;fcghz&#39;: self.N.node[na][&#39;wstd&#39;][w][&#39;fcghz&#39;],
                                    &#39;fbminghz&#39;: self.fGHz[0],
                                    &#39;fbmaxghz&#39;: self.fGHz[-1],
                                    &#39;nf&#39;: len(self.fGHz),
                                    &#39;aktk_id&#39;:aktk_id,
                                    &#39;sig_id&#39;: self.DL.dexist[&#39;sig&#39;][&#39;grpname&#39;],
                                    &#39;ray_id&#39;: self.DL.dexist[&#39;ray&#39;][&#39;grpname&#39;],
                                    &#39;Ct_id&#39;: self.DL.dexist[&#39;Ct&#39;][&#39;grpname&#39;],
                                    &#39;H_id&#39;: self.DL.dexist[&#39;H&#39;][&#39;grpname&#39;],
                                                },columns=[&#39;id_a&#39;, &#39;id_b&#39;,
                                              &#39;x_a&#39;, &#39;y_a&#39;, &#39;z_a&#39;,
                                              &#39;x_b&#39;, &#39;y_b&#39;, &#39;z_b&#39;,
                                              &#39;d&#39;, &#39;eng&#39;, &#39;typ&#39;,
                                              &#39;wstd&#39;, &#39;fcghz&#39;,
                                              &#39;fbminghz&#39;, &#39;fbmaxghz&#39;, &#39;fstep&#39;, &#39;aktk_id&#39;,
                                              &#39;sig_id&#39;, &#39;ray_id&#39;, &#39;Ct_id&#39;, &#39;H_id&#39;
                                              ],index= [t])  #self._time[ut]])

                        self.savepd(df)</div>

<div class="viewcode-block" id="Simul.replace_data"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.replace_data">[docs]</a>    def replace_data(self, df):
        &quot;&quot;&quot;check if a dataframe df already exists in self.data

        Parameters
        ----------
        df : pd.DataFrame

        Returns
        -------

        boolean
            True if already exists
            False otherwise

        &quot;&quot;&quot;
        self.data[(self.data.index == df.index) &amp;
                  (self.data[&#39;id_a&#39;] == df[&#39;id_a&#39;].values[0]) &amp;
                  (self.data[&#39;id_b&#39;] == df[&#39;id_b&#39;].values[0]) &amp;
                  (self.data[&#39;wstd&#39;] == df[&#39;wstd&#39;].values[0])]=df.values</div>



<div class="viewcode-block" id="Simul.check_exist"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.check_exist">[docs]</a>    def check_exist(self, df):
        &quot;&quot;&quot;check if a dataframe df already exists in self.data

        Parameters
        ----------
        df : pd.DataFrame

        Returns
        -------

        boolean
            True if already exists
            False otherwise

        &quot;&quot;&quot;
        # check init case 
        if not len(self.data.index) == 0:

            ud = self.data[(self.data.index == df.index) &amp; 
                           (self.data[&#39;id_a&#39;] == df[&#39;id_a&#39;].values[0]) &amp; 
                           (self.data[&#39;id_b&#39;] == df[&#39;id_b&#39;].values[0]) &amp; 
                           (self.data[&#39;wstd&#39;] == df[&#39;wstd&#39;].values[0])]

            if len(ud) == 0:
                return False
            else :
                return True
        else :
            return False</div>


<div class="viewcode-block" id="Simul.savepd"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.savepd">[docs]</a>    def savepd(self,df):
        &quot;&quot;&quot; save data information of a simulation

        Parameters
        ----------

        df : one index data

        Notes
        -----


        &quot;&quot;&quot;
        filenameh5 = pyu.getlong(self.filename, pstruc[&#39;DIRLNK&#39;])
        store = pd.HDFStore(filenameh5)
        #self.data=self.data.sort()
        store.append(&#39;df&#39;,df)
        store.close()</div>

<div class="viewcode-block" id="Simul.loadpd"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.loadpd">[docs]</a>    def loadpd(self):
        &quot;&quot;&quot; load data from previous simulations
        &quot;&quot;&quot;
        filenameh5 = pyu.getlong(self.filename, pstruc[&#39;DIRLNK&#39;])
        store = pd.HDFStore(filenameh5)
        #self.data = pd.read_hdf(filenameh5,&#39;df&#39;)
        self.data = store.get(&#39;df&#39;)
        self.data.index.name=&#39;t&#39;
        self.data = self.data.sort()</div>

<div class="viewcode-block" id="Simul.get_sim_time"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.get_sim_time">[docs]</a>    def get_sim_time(self,t):
        &quot;&quot;&quot; retrieve closest time value in regard of passed t value in parameter
        &quot;&quot;&quot;

        if not isinstance(t,list) and not isinstance(t,np.ndarray):
            return np.array([self.time[np.where(self.time &lt;=t)[0][-1]]])
        else :
            return np.array([self.get_sim_time(tt) for tt in t])[:,0]</div>


<div class="viewcode-block" id="Simul.get_df_from_link"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.get_df_from_link">[docs]</a>    def get_df_from_link(self,id_a,id_b,wstd=&#39;&#39;):
        &quot;&quot;&quot; Return a restricted data frame for a specific link

            Parameters
            ----------

            id_a : str
                node id a
            id_b: str
                node id b
            wstd: str
                optionnal :wireslees standard
        &quot;&quot;&quot;
        if wstd == &#39;&#39;:
            return self.data[(self.data[&#39;id_a&#39;]==id_a) &amp;
                             (self.data[&#39;id_b&#39;]==id_b)]
        else :
            return self.data[(self.data[&#39;id_a&#39;]==id_a) &amp;
                             (self.data[&#39;id_b&#39;]==id_b) &amp;
                             self.data[&#39;wstd&#39;]==wstd]</div>


<div class="viewcode-block" id="Simul.update_pos"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.update_pos">[docs]</a>    def update_pos(self, t):
        &quot;&quot;&quot; update positions of devices and bodies for a given time index

        Parameters
        ----------

        t : int
            time value

        &quot;&quot;&quot;

        # if a bodies are involved in simulation
        if ((self.todo[&#39;OB&#39;]) or (self.todo[&#39;B2B&#39;]) or (self.todo[&#39;B2I&#39;])):
            nodeid = []
            pos = []
            devlist = []
            orient = []
            for up, person in enumerate(self.dpersons.values()):
                person.settopos(self._traj[up], t=t, cs=True)
                name = person.name
                dev = person.dev.keys()
                devlist.extend(dev)
                #nodeid.extend([n + &#39;_&#39; + name for n in dev])
                pos.extend([person.dcs[d][:, 0] for d in dev])
                orient.extend([person.acs[d] for d in dev])
            # TODO !!!!!!!!!!!!!!!!!!!!
            # in a future version , the network update must also update
            # antenna position in the device coordinate system
            self.N.update_pos(devlist, pos, now=t)
            self.N.update_orient(devlist, orient, now=t)
        self.N.update_dis()</div>



<div class="viewcode-block" id="Simul.get_value"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.get_value">[docs]</a>    def get_value(self,**kwargs):
        &quot;&quot;&quot; retrieve output parameter at a specific time

        Parameters
        ----------

        typ : list
                list of parameters to be retrieved
                (R | C |H | ak | tk | rss )
        links: list
            dictionnary of link to be evaluated (key is wtsd and value is a list of links)
            (if [], all link are considered)
        t: int or np.array
            list of timestamp to be evaluated | singlr time instant

        Returns
        -------

        output: dict
                [link_key][&#39;t&#39;]
                          [&#39;ak&#39;]
                ...
        &quot;&quot;&quot;



        # get time
        defaults = {&#39;t&#39;: 0,
                    &#39;typ&#39;:[&#39;ak&#39;],
                    &#39;links&#39;: {},
                    &#39;wstd&#39;:[],
                    &#39;angles&#39;:False
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]

        # allocate an empty dictionnary for wanted selected output
        output={}

        # manage time t can be a list or a float
        t = kwargs[&#39;t&#39;]
        t = self.get_sim_time(t)
        dt = self.time[1]-self.time[0]

        # manage links
        plinks = kwargs[&#39;links&#39;]
        links=[]
        if isinstance(plinks,dict):
            for l in plinks.keys():
                links.extend(plinks[l])

        if len(links) == 0:
            raise AttributeError(&#39;Please give valid links to get values&#39;)
        # output[&#39;t&#39;]=[]
        # output[&#39;time_to_simul&#39;]=[]
        # for each requested time step
        for tt in t :
            # for each requested links
            for link in links:
                linkname=link[0]+&#39;-&#39;+link[1]
                if not output.has_key(linkname):
                    output[linkname] = {}
                if not output[linkname].has_key(&#39;t&#39;):
                    output[linkname][&#39;t&#39;] = []

                # restrict global dataframe self.data to the specific link
                df = self.get_df_from_link(link[0],link[1])
                # restrict global dataframe self.data to the specific z
                df = df[(df.index &gt; tt-dt) &amp; (df.index &lt;= tt+dt)]

                if len(df) != 0:
                    output[linkname][&#39;t&#39;].append(tt)
                    if len(df)&gt;1:
                        print(&#39;Warning possible issue in self.get_value&#39;)
                    line = df.iloc[-1]
                    # # get info of the corresponding timestamp
                    # line = df[(df[&#39;id_a&#39;] == link[0]) &amp; (df[&#39;id_b&#39;] == link[1])].iloc[-1]
                    # if len(line) == 0:
                    #     line = df[(df[&#39;id_b&#39;] == link[0]) &amp; (df[&#39;id_a&#39;] == link[1])]
                    #     if len(line) == 0:
                    #         raise AttributeError(&#39;invalid link&#39;)

                    #retrieve correct position and orientation given the time
                    #self.update_pos(t=tt)
                    # antennas positions
                    #self.DL.a = self.N.node[link[0]][&#39;p&#39;]
                    #self.DL.b = self.N.node[link[1]][&#39;p&#39;]
                    # antennas orientation
                    #self.DL.Ta = self.N.node[link[0]][&#39;T&#39;]
                    #self.DL.Tb = self.N.node[link[1]][&#39;T&#39;]
                    # antennas object
                    #self.DL.Aa = self.N.node[link[0]][&#39;ant&#39;][&#39;antenna&#39;]
                    #self.DL.Ab = self.N.node[link[1]][&#39;ant&#39;][&#39;antenna&#39;]
                    # get the antenna index
                    #uAa_opt, uAa = self.DL.get_idx(&#39;A_map&#39;,self.DL.Aa._filename)
                    #uAb_opt, uAb = self.DL.get_idx(&#39;A_map&#39;,self.DL.Ab._filename)

                    if &#39;ak&#39; in kwargs[&#39;typ&#39;] or &#39;tk&#39; in kwargs[&#39;typ&#39;] or &#39;rss&#39; in kwargs[&#39;typ&#39;]:
                        H_id = line[&#39;H_id&#39;].decode(&#39;utf8&#39;)
                        # load the proper link
                        # parse index
                        lid = H_id.split(&#39;_&#39;)
                        #if (lid[5]==str(uAa))&amp;(lid[6]==str(uAb)):
                        self.DL.load(self.DL.H,H_id)
                        if &#39;ak&#39; in kwargs[&#39;typ&#39;]:
                            if not output[linkname].has_key(&#39;ak&#39;):
                                output[linkname][&#39;ak&#39;]=[]
                            output[linkname][&#39;ak&#39;].append(copy.deepcopy(self.DL.H.ak))
                        if &#39;tk&#39; in kwargs[&#39;typ&#39;]:
                            if not output[linkname].has_key(&#39;tk&#39;):
                                output[linkname][&#39;tk&#39;]=[]
                            output[linkname][&#39;tk&#39;].append(copy.deepcopy(self.DL.H.tk))
                        if &#39;rss&#39; in kwargs[&#39;typ&#39;]:
                            if not output[linkname].has_key(&#39;rss&#39;):
                                output[linkname][&#39;rss&#39;]=[]
                            output[linkname][&#39;rss&#39;].append(copy.deepcopy(self.DL.H.rssi()))

                    if &#39;R&#39; in kwargs[&#39;typ&#39;]:
                        if not output[linkname].has_key(&#39;R&#39;):
                            output[linkname][&#39;R&#39;]=[]
                        ray_id = line[&#39;ray_id&#39;]
                        self.DL.load(self.DL.R,ray_id)
                        output[linkname][&#39;R&#39;].append(copy.deepcopy(self.DL.R))

                    if &#39;C&#39; in kwargs[&#39;typ&#39;]:
                        if not output[linkname].has_key(&#39;C&#39;):
                            output[linkname][&#39;C&#39;]=[]
                        Ct_id = line[&#39;Ct_id&#39;]
                        self.DL.load(self.DL.C,Ct_id)

                        if kwargs[&#39;angles&#39;]:
                            self.DL.C.islocal=False
                            self.DL.C.locbas(Tt=self.DL.Ta, Tr=self.DL.Tb)
                        #T channel
                        output[linkname][&#39;C&#39;].append(copy.deepcopy(self.DL.C))


                    if &#39;H&#39; in kwargs[&#39;typ&#39;]:
                        if not output[linkname].has_key(&#39;H&#39;):
                            output[linkname][&#39;H&#39;]=[]
                        H_id = line[&#39;H_id&#39;]
                        lid = H_id.split(&#39;_&#39;)
                        #if (lid[5]==str(uAa))&amp;(lid[6]==str(uAb)):
                        self.DL.load(self.DL.H,H_id)
                        output[linkname][&#39;H&#39;].append(copy.deepcopy(self.DL.H))

                # if time value not found in dataframe
                else:
                    if not output[linkname].has_key(&#39;time_to_simul&#39;):
                        output[linkname][&#39;time_to_simul&#39;] = []
                    output[linkname][&#39;time_to_simul&#39;].append(tt)


        for l in output.keys():
            if output[l].has_key(&#39;time_to_simul&#39;):
                print(&#39;link&#39;, l , &#39;require simulation for timestamps&#39;, output[l][&#39;time_to_simul&#39;])


        return(output)</div>


<div class="viewcode-block" id="Simul.get_link"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.get_link">[docs]</a>    def get_link(self,**kwargs):
        &quot;&quot;&quot; retrieve a Link specific time from a simultraj

        Parameters
        ----------

        typ : list
                list of parameters to be retrieved
                (ak | tk | R |C)
        links: list
            dictionnary of link to be evaluated (key is wtsd and value is a list of links)
            (if [], all link are considered)
        t: int or np.array
            list of timestamp to be evaluated | singlr time instant

        Returns
        -------

        DL : DLink

        Examples
        --------

            &gt;&gt;&gt; from pylayers.simul.simultraj import *
            &gt;&gt;&gt; from pylayers.measures.cormoran import *
            &gt;&gt;&gt; C=CorSer(serie=6,day=11,layout=True)
            &gt;&gt;&gt; S = Simul(C,verbose=False)
            &gt;&gt;&gt; DL = S.get_link(typ=[&#39;R&#39;,&#39;C&#39;,&#39;H&#39;])
        &quot;&quot;&quot;



        # get time
        defaults = {&#39;t&#39;: 0,
                    &#39;typ&#39;:[&#39;ak&#39;],
                    &#39;links&#39;: {},
                    &#39;wstd&#39;:[],
                    &#39;angles&#39;:False
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]

        output={}

        # manage time
        t = kwargs[&#39;t&#39;]
        t = self.get_sim_time(t)
        dt = self.time[1]-self.time[0]

        # manage links
        plinks = kwargs[&#39;links&#39;]
        links=[]
        if isinstance(plinks,dict):
            for l in plinks.keys():
                links.extend(plinks[l])

        if len(links) == 0:
            raise AttributeError(&#39;Please give valid links to get values&#39;)
        # output[&#39;t&#39;]=[]
        # output[&#39;time_to_simul&#39;]=[]
        # for each requested time step
        for tt in t :
            # for each requested links
            for link in links:
                linkname=link[0]+&#39;-&#39;+link[1]
                if not output.has_key(linkname):
                    output[linkname] = {}
                if not output[linkname].has_key(&#39;t&#39;):
                    output[linkname][&#39;t&#39;] = []


                # restrict global dataframe self.data to the specific link
                df = self.get_df_from_link(link[0],link[1])
                # restrict global dataframe self.data to the specific z
                df = df[(df.index &gt; tt-dt) &amp; (df.index &lt;= tt+dt)]

                if len(df) != 0:
                    output[linkname][&#39;t&#39;].append(tt)
                    if len(df)&gt;1:
                        print(&#39;Warning possible issue in self.get_link&#39;)
                    line = df.iloc[-1]
                    # # get info of the corresponding timestamp
                    # line = df[(df[&#39;id_a&#39;] == link[0]) &amp; (df[&#39;id_b&#39;] == link[1])].iloc[-1]
                    # if len(line) == 0:
                    #     line = df[(df[&#39;id_b&#39;] == link[0]) &amp; (df[&#39;id_a&#39;] == link[1])]
                    #     if len(line) == 0:
                    #         raise AttributeError(&#39;invalid link&#39;)

                    #retrieve correct position and orientation given the time
                    self.update_pos(t=tt)
                    self.DL.a = self.N.node[link[0]][&#39;p&#39;]
                    self.DL.b = self.N.node[link[1]][&#39;p&#39;]
                    self.DL.Ta = self.N.node[link[0]][&#39;T&#39;]
                    self.DL.Tb = self.N.node[link[1]][&#39;T&#39;]
                    #self.DL.Aa = self.N.node[link[0]][&#39;ant&#39;][&#39;antenna&#39;]
                    #self.DL.Ab = self.N.node[link[1]][&#39;ant&#39;][&#39;antenna&#39;]

                    #H_id = line[&#39;H_id&#39;].decode(&#39;utf8&#39;)
                    #self.DL.load(self.DL.H,H_id)

                    if &#39;R&#39; in kwargs[&#39;typ&#39;]:
                        ray_id = line[&#39;ray_id&#39;]
                        self.DL.load(self.DL.R,ray_id)

                    if &#39;C&#39; in kwargs[&#39;typ&#39;]:
                        Ct_id = line[&#39;Ct_id&#39;]
                        self.DL.load(self.DL.C,Ct_id)

                        if kwargs[&#39;angles&#39;]:
                            self.DL.C.islocal=False
                            self.DL.C.locbas(Tt=self.DL.Ta, Tr=self.DL.Tb)

                    if &#39;H&#39; in kwargs[&#39;typ&#39;]:
                        H_id = line[&#39;H_id&#39;]
                        self.DL.load(self.DL.H,H_id)

        return(self.DL)</div>



    def _show3(self, **kwargs):
        &quot;&quot;&quot; 3D show using Mayavi

        Parameters
        ----------

        t: float
            time index
        link: list
            [id_a, id_b]
            id_a : node id a
            id_b : node id b
        &#39;lay&#39;: bool
            show layout
        &#39;net&#39;: bool
            show net
        &#39;body&#39;: bool
            show bodies
        &#39;rays&#39;: bool
            show rays
        &quot;&quot;&quot;

        defaults = {&#39;t&#39;: 0,
                    &#39;link&#39;: [],
                    &#39;wstd&#39;:[],
                    &#39;lay&#39;: True,
                    &#39;net&#39;: True,
                    &#39;body&#39;: True,
                    &#39;rays&#39;: True,
                    &#39;ant&#39;: False

                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k] = defaults[k]

        link = kwargs[&#39;link&#39;]
        self.update_pos(kwargs[&#39;t&#39;])

        if len(self.data) != 0:
            df = self.data[self.data.index == pd.to_datetime(kwargs[&#39;t&#39;])]
            if len(df) != 0:
                raise AttributeError(&#39;invalid time&#39;)


            # default
            if link ==[]:
                line = df[df.index&lt;=pd.to_datetime(0)]
                link = [line[&#39;id_a&#39;].values[0],line[&#39;id_b&#39;].values[0]]
            else :
                # get info of the corresponding timestamp
                line = df[(df[&#39;id_a&#39;] == link[0]) &amp; (df[&#39;id_b&#39;] == link[1])]
            if len(line) == 0:
                line = df[(df[&#39;id_b&#39;] == link[0]) &amp; (df[&#39;id_a&#39;] == link[1])]
                if len(line) == 0:
                    raise AttributeError(&#39;invalid link&#39;)
            rayid = line[&#39;ray_id&#39;].values[0]


            self.DL.a = self.N.node[link[0]][&#39;p&#39;]
            self.DL.b = self.N.node[link[1]][&#39;p&#39;]
            self.DL.Ta = self.N.node[link[0]][&#39;T&#39;]
            self.DL.Tb = self.N.node[link[1]][&#39;T&#39;]
            self.DL.load(self.DL.R,rayid)





            self.DL._show3(newfig= False,
                           lay= kwargs[&#39;lay&#39;],
                           rays= kwargs[&#39;rays&#39;],
                           ant=False)
        else :
            self.DL._show3(newfig= False,
                           lay= True,
                           rays= False,
                           ant=False)
        if kwargs[&#39;net&#39;]:
            self.N._show3(newfig=False)
        if kwargs[&#39;body&#39;]:
            for p in self.dpersons:
                self.dpersons[p]._show3(newfig=False,
                                        topos=True,
                                        pattern=kwargs[&#39;ant&#39;])

    # def _saveh5_init(self):
    #     &quot;&quot;&quot; initialization of the h5py file
    #     &quot;&quot;&quot;
    #     filenameh5 = pyu.getlong(self.filename, pstruc[&#39;DIRLNK&#39;])
    #     import ipdb
    #     try:
    #         f5 = h5py.File(filenameh5, &#39;w&#39;)
    #         f5.create_dataset(&#39;time&#39;, shape=self.time.shape, data=self.time)
    #         f5.close()
    #     except:
    #         f5.close()
    #         raise NameError(&#39;simultra.saveinit: \
    #                         issue when writting h5py file&#39;)

    def _saveh5(self, ut, ida, idb, wstd):
        &quot;&quot;&quot; Save in h5py format

        Parameters
        ----------

        ut : int
            time index in self.time
        ida : string
            node a index
        idb : string
            node b index
        wstd : string
            wireless standard of used link

        Notes
        -----

        Dataset organisation:

        simultraj_&lt;trajectory_filename.h5&gt;.h5
            |
            |time
            |    ...
            |
            |/&lt;tidx_ida_idb_wstd&gt;/ |attrs
            |                      |a_k
            |                      |t_k


        Root dataset :
        time : array
            range of simulation time

        Group identifier :
            tidx : index in time dataset
            ida : node a index in Network
            idb : node b index in Network
            wstd : wireless standar of link interest


        Inside group:
            a_k : alpha_k values
            t_k : tau_k values

        See Also
        --------

        pylayers.simul.links

        &quot;&quot;&quot;

        filenameh5 = pyu.getlong(self.filename, pstruc[&#39;DIRLNK&#39;])
        grpname = str(ut) + &#39;_&#39; + ida + &#39;_&#39; + idb + &#39;_&#39; + wstd
        # try/except to avoid loosing the h5 file if
        # read/write error
        try:
            fh5 = h5py.File(filenameh5, &#39;a&#39;)
            if not grpname in fh5.keys():
                fh5.create_group(grpname)
                f = fh5[grpname]
                # for k in kwargs:
                #     f.attrs[k] = kwargs[k]

                f.create_dataset(&#39;alphak&#39;,
                                 shape=self._ak.shape,
                                 maxshape=(None),
                                 data=self._ak)
                f.create_dataset(&#39;tauk&#39;,
                                 shape=self._tk.shape,
                                 maxshape=(None),
                                 data=self._tk)
            else:
                pass#print grpname + &#39; already exists in &#39; + filenameh5


            fh5.close()
        except:
            fh5.close()
            raise NameError(&#39;Simultraj._saveh5: issue when writting h5py file&#39;)


    def _loadh5(self, grpname):
        &quot;&quot;&quot; Load in h5py format

        Parameters
        ----------

        grpname : string
            group name which can be found sin self.data aktk_idx column

        Returns
        -------

        (ak, tk, conf)

        ak : ndarray:
            alpha_k
        tk : ndarray:
            alpha_k
        &quot;&quot;&quot;

        filenameh5 = pyu.getlong(self.filename, pstruc[&#39;DIRLNK&#39;])
        # try/except to avoid loosing the h5 file if
        # read/write error
        try:
            fh5 = h5py.File(filenameh5, &#39;r&#39;)
            if not grpname in fh5.keys():
                fh5.close()
                raise NameError(grpname + &#39; cannot be reached in &#39; + self.filename)
            f = fh5[grpname]
            # for k in f.attrs.keys():
            #     conf[k]=f.attrs[k]
            ak = f[&#39;alphak&#39;][:]
            tk = f[&#39;tauk&#39;][:]
            fh5.close()

            return ak, tk
        except:
            fh5.close()
            raise NameError(&#39;Simultraj._loadh5: issue when reading h5py file&#39;)


<div class="viewcode-block" id="Simul.tocsv"><a class="viewcode-back" href="../../../api/pylayers.simul.simultraj.Simul.html#pylayers.simul.simultraj.Simul.tocsv">[docs]</a>    def tocsv(self, ut, ida, idb, wstd,init=False):

        filecsv = pyu.getlong(self._filecsv,pstruc[&#39;DIRLNK&#39;])

        with open(filecsv, &#39;a&#39;) as csvfile:
            fil = csv.writer(csvfile, delimiter=&#39;;&#39;,
                             quoting=csv.QUOTE_MINIMAL)
            if init:
                keys = self.data.iloc[-1].keys()
                data = [k for k in keys]
                data .append(&#39;ak&#39;)
                data .append(&#39;tk&#39;)
                fil.writerow(data)

            values = self.data.iloc[-1].values
            data = [v for v in values]
            sak = str(self._ak.tolist())
            stk = str(self._tk.tolist())
            data.append(sak)
            data.append(stk)
            fil.writerow(data)</div></div>

if (__name__ == &quot;__main__&quot;):
    #plt.ion()
    doctest.testmod()
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, PyLayers developer team.
      Last updated on May 31, 2018.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>