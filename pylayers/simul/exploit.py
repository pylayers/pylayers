from pylayers.util import project
from pylayers.signal.bsignal import *
from pylayers.simul.simulem import *
import pylayers.util.pyutil as pyu
import ConfigParser
import matplotlib.pylab as plt
import itertools
import pdb



class Exploit(object):
    def __init__(self,simnetfile='pyray.ini'):
        self.simnetfile=simnetfile
        self.load()

    def load(self):
        """
        Load simulnet_data configuration file
        """
        self.simcfg = ConfigParser.ConfigParser()
        self.simcfg.read(pyu.getlong(self.simnetfile,pstruc['DIRNETSAVE']))
        self.Lfilename = self.simcfg.get('layout','layoutname')
        self.lAG = eval(self.simcfg.get('nodes','ag'))
        self.lAP = eval(self.simcfg.get('nodes','ap'))
        self.uptime = eval(self.simcfg.get('simulation','updatetime'))
        # create a Simul object with the correct layout
        self.S = Simul()
        self.S.layout(self.Lfilename,'matDB.ini','slabDB.ini')
        self.lap = len(self.lAP)
        self.lag = len(self.lAG)

        self.L = self.S.L
        try:
            self.L.dumpr()
            print 'Layout graphs are loaded from ',basename,'/struc'
        except:
        #self.L.sl = sl
        #self.L.loadGr(G1)            
            print 'First time your use the Layout.Graphs are curently build, it may take few minutes.'
            self.L.buildGt()
            self.L.dumpw()



    def compute(self):
        """
        Compute Raytracing simulation with the given simulation files 
        """
        #
        ### STEP 1 : all mobile node with all agent
        #

        self.S.clean_project(verbose=True)

        for apidx,ap in enumerate(self.lAP):
            self.S.tx = RadioNode(typ='tx',name=ap)
            self.S.tx.loadini(ap+'.ini',rep=pstruc['DIRNETSAVE'])
            for agidx,ag in enumerate(self.lAG):
                print '---------------------'
                print ' Raytracing for :    '
                print ' AP #',self.lAP[apidx-1] ,' / AG #',ag
                print '---------------------'
                print ' Computed :'
                print 'AP:',apidx-1,'/',self.lap+1
                print 'AG:',agidx,'/',self.lag
                print '---------------------'
                self.S.rx = RadioNode(typ='rx',name=ag)
                self.S.rx.loadini(ag+'.ini',rep=pstruc['DIRNETSAVE'])
                self.S.run(apidx+1,range(1,self.S.rx.N+1))

        #### STEP 2 : all mobile/mobile

        icag = itertools.combinations(self.lAG,2)
        for cag in icag:
            self.S.tx = RadioNode(typ='tx',name=cag[0])
            self.S.tx.loadini(cag[0]+'.ini',rep=pstruc['DIRNETSAVE'])
            self.S.rx = RadioNode(typ='tx',name=cag[1])
            self.S.rx.loadini(cag[1]+'.ini',rep=pstruc['DIRNETSAVE'])
            lidxpts = range(1,self.S.rx.N+1)
            print '---------------------'
            print ' Raytracing for :    '
            print ' AG #', cag[0] ,' / AG #',cag[1]
            print '---------------------'
            for n in lidxpts:
                print ' trajectory point #',n,'/',self.S.rx.N+1
                print '---------------------'
                self.S.run(n,n)


    def pltcir(self,itx,irx,pn,fig=[]):
        """
            Plot channel impulse response for Tx,Rx and a specified position
            Parameters
            ----------
                itx : int
                    node number
                irx : int
                    node number
                pn : int
                    position index of the Rx

        """
        if fig == []:
            fig = plt.figure(2)

        fig.clf()

        cir = TUsignal()
        spn = str(pn)
        line = 'defaultcir-' +str(itx) +'-'+str(irx)+'-p'+spn.zfill(3)
        print 'load : ',line,'.mat'
        try:
            cir.readcir(line,str(itx))
        except:
            return False
        cir.show(fig)
        return True


    def pltciri(self,itx,irx):
        """
        Plot channel impulse response interactiveley.
        diplay all node position of Tx and Rx and chose 
        for which link you display the CIR.

        Once you have call self.pltciri(node1,node2)
        1) Press 't' on the displayed graph to chose the Tx
        2) Press 'x' on the displayed graph to chose the Rx
        3) Press Enter to display CIR betwen Tx-Rx


        Parameters
        ----------
            itx : int
                node number
            irx : int
                node number

        usage
        >>> W=W2()
        >>> W.pltciri(6,1)

        """
        plt.ion()
        fig1 = plt.figure(1)
        ax=fig1.add_subplot(111)
        self.ax2 = fig1.add_subplot(111)
        self.L.showG(fig=fig1,graph='')
        self.S.tx = RadioNode(typ='tx',name=itx)
        self.S.tx.loadini(str(itx)+'.ini',rep=pstruc['DIRNETSAVE'])
        self.S.rx = RadioNode(typ='rx',name=irx)
        self.S.rx.loadini(str(irx)+'.ini',rep=pstruc['DIRNETSAVE'])
        ax.plot(self.S.tx.position[0,:],self.S.tx.position[1,:],'ob')
        ax.plot(self.S.rx.position[0,:],self.S.rx.position[1,:],'or')
        plt.show()
        print '1. Press \'t\' and click to select a Tx '
        print '2. Press \'x\' and click to select a Rx '  
        print '3. Press Enter to see the associated CIR '  
        self.key=''
        self.x1=''
        self.x2=''
        self.y1=''
        self.y2=''
        self.n1=''
        self.n2=''
        self.pos1=''
        self.pos2=''
        self.c1=[]
        self.c2=[]
        cid=fig1.canvas.mpl_connect('button_press_event', self.onclick)
        cid=fig1.canvas.mpl_connect('key_press_event', self.on_key)

    def onclick(self,event):
        """
            Events on click
        """
        if event.button == 1:
            print self.key
            if self.key =='t':
                self.x1 = event.xdata
                self.y1 = event.ydata
                self.n1,self.pos1=self.srchpoint(self.x1,self.y1)
                print 'select node1(Tx) # ',self.n1,
            if self.key =='x':
                self.x2 = event.xdata
                self.y2 = event.ydata
                self.n2,self.pos2=self.srchpoint(self.x2,self.y2)
                print 'select node2(Rx) # ',self.n2, ', at position #', self.pos2+1
            if self.key == 'enter':
                pass



    def on_key(self,event):
        """
            Events on key stroke
        """
        if event.key == 't':
            self.key = 't'
        if event.key == 'x':
            self.key = 'x'
        if event.key == 'enter':
            inv=False
            case = ''
            if self.pos1 !='' and self.pos2 !='':
                if self.n1 == self.n2:
                    print 'ERROR :tx and rx on the same node'
                else :
                    if str(self.n1) in self.lAG and str(self.n2) in self.lAG:
                        upos = self.pos2[0]+1
                        case = '2agents'
                    elif str(self.n2) in self.lAP:
                        upos = self.pos1[0]+1
                    else :
                        upos = self.pos2[0]+1


                    if self.pltcir(self.n1,self.n2,upos):
                        pass
                    else: 
                        self.pltcir(self.n2,self.n1,upos)
                        inv=True
                        print inv

                    ### manage black cross for involved nodes
                    try:
                        self.c1.pop(0).remove()
                        self.c2.pop(0).remove()
                    except:
                        pass
         
                    if case == '2agents':
                    ### manage 2 mobile nodes
                        self.c1=self.ax2.plot(self.S.tx.position[0,upos-1],self.S.tx.position[1,upos-1],'xk',ms=10.,mew=3.)
                        self.c2=self.ax2.plot(self.S.rx.position[0,upos-1],self.S.rx.position[1,upos-1],'xk',ms=10.,mew=3.)
                    else:
                        if self.S.tx.N == 1:
                            self.c1=self.ax2.plot(self.S.tx.position[0,0],self.S.tx.position[1,0],'xk',ms=10.,mew=3.)
                            self.c2=self.ax2.plot(self.S.rx.position[0,upos-1],self.S.rx.position[1,upos-1],'xk',ms=10.,mew=3.)
                        else :
                            self.c1=self.ax2.plot(self.S.tx.position[0,upos-1],self.S.tx.position[1,upos-1],'xk',ms=10.,mew=3.)
                            self.c2=self.ax2.plot(self.S.rx.position[0,0],self.S.rx.position[1,0],'xk',ms=10.,mew=3.)

#                    ### manage 2 mobile nodes to take position of the 2nd click
#                    if str(self.S.tx.name) in self.lAG and str(self.S.rx.name) in self.lAG :
#                        self.pos1 = self.pos2
#                    

    def srchpoint(self,x,y):
        """
        Search from the closest point (x,y) into self.tx.position and self.rx.position
        
        Returns
        -------
            N : int
                node ID
            pos : int
                index of the closest position 
        """
        t = self.S.tx.position[:2,:]
        r = self.S.rx.position[:2,:]
        p = np.array((x,y))
        d1 = np.sqrt(np.sum((t.T-p)**2,axis=1))
        d2 = np.sqrt(np.sum((r.T-p)**2,axis=1))
        d1m=np.min(d1)
        d2m=np.min(d2)
        if d1m < d2m:
            n = self.S.tx.name
            pos = np.nonzero(d1==d1m)[0]
        else :
            n = self.S.rx.name
            pos = np.nonzero(d2==d2m)[0]
        return (n,pos)
#cid = fig.canvas.mpl_connect('button_press_event', onclick)


if (__name__ == "__main__"):
    E=Exploit()
    E.pltciri(1,2)

