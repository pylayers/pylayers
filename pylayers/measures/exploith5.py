import h5py
import os
#import ipdb
import pdb
import re
import numpy as npexit
from pylayers.antprop.channel import *
from pylayers.util.project import *
import pylayers.util.pyutil as pyu
import ConfigParser
import numpy.linalg as la
from numpy.linalg import svd
from numpy.fft import *
import time

"""

Module to handle scanner data stored and exploited
in hdf5 format.

Author : Mamadou Dialounke BALDE

.. currentmodule:: pylayers.measures.exploith5

.. autosummary::
    :toctree: generated

mesh5 Class
===========

.. autosummary::
    :toctree: generated/

    mesh5.__init__
    mesh5.__repr__
    mesh5.readcal
    mesh5.read
    mesh5.calibrate
    mesh5.saveini

"""


class Mesh5(PyLayers):
    """ Class handling hdf5 measurement files
    """
    def __init__(self,_filename='',**kwargs):
        """
        """
        if _filename!='':
            if '.h5' not in _filename:
                _filename = _filename + '.h5'
            filename = pyu.getlong(_filename,pstruc['DIRMES'])
            if os.path.isfile(filename):
                self._filename = _filename
                self.filename = filename
                fd  = h5py.File(self.filename,'r')
                lkeys = fd.keys()
                lcal = [ c for c in lkeys if  'cal' in c]
                lmes = [ m for m in lkeys if  'mes' in m]
                self.gcal = {}
                for ke in lcal: 
                    num = int(ke.replace('cal',''))
                    self.gcal[ke] = self.get_dcal(gcal=num)
                self.dmes = {}
                for ke in lmes:
                    self.dmes[ke]=''
                fd.close

        defaults = {
                    'Nt': 8,
                    'Nr': 4,
                    'imes' : 4
                    }

        for k in defaults:
            if k not in kwargs:
                kwargs[k]=defaults[k]

        self.Nr  = kwargs.pop('Nr')
        self.Nt  = kwargs.pop('Nt')
        self.imes  = kwargs.pop('imes')



    def dir(self):
        path = pyu.getlong('',pstruc['DIRMES'])
        fileh5 = [ f for f in os.listdir(path) if os.path.isfile(os.path.join(path,f)) ]
        for k in fileh5:
            if '.h5' in k:
                print k

    def __repr__(self):
        """
        """
        if "filename" in self.__dict__:
            st = ''
            st = st + '-------------------------------------\n'
            st = st + '              Parameters             \n'
            st = st + '-------------------------------------\n'
            st = st + 'Directory  : '+ str(self.filename) +'\n'
            st = st + '-------------------------------------\n'


            if 'mes' not in self.__dict__:
                st = st +'\n No measurement loaded \n'
            else:
                st = st + 'Index : '+ str(self.ix)+'\n'
                st = st + 'Position : '+str(self.pt)+'\n'
                if self.mes.calibrated:
                    st = st+'\n Measurement calibrated : Yes\n'
                else:
                    st = st+'\n Measurement calibrated : No\n'

            f  = h5py.File(self.filename,'r')
            ke = f.keys()


            for k in ke:
                st = st + k + '\n'
                for ja in f[k].attrs.keys():
                    st = st + ' ' + ja + ' : ' +  str(f[k].attrs[ja])+ '\n'
                st = st+'\n'
                if 'mes' not in k:
                    try:
                        for jb in f[k]:
                            st = st +'\t\t' + jb + '\t'
                            for jba in f[k][jb].attrs.keys():
                                st = st + str(f[k][jb].attrs[jba])+ '\t'
                            st = st+'\n'
                            try:
                                for jc in f[k][jb]:
                                    st = st +'\t\t' + jb + '\t' + jc + '\t'
                                    for jca in f[k][jb][jc].attrs.keys():
                                        st = st + str(f[k][jb][jc].attrs[jca])+ '\t'
                                    st = st+'\n'
                            except:
                                st = st+'\n'

                    except:
                        st = st+'\n'
            f.close()
            #st = st + 'File  : '+ str(self.f) +'\n'
        else:
            st = 'file  not set'

        return(st)

    def info(self,num=0):
        f  = h5py.File(self.filename,'r')
        ke = f.keys()
        if num ==0:
            for k in ke:
                if 'mes' in k:
                    print k
                    print " ",f[k].attrs['time']
                    print " ",f[k].attrs['comment']
        else:
            k = 'mes'+str(num)
            print k
            print " Date of Measurement : ",f[k].attrs['time']
            print " Author : ",f[k].attrs['author']
            print " Comment : ",f[k].attrs['comment']
            print " Moving axe(s) : ",f[k].attrs['axes']
            print " Number of positions : ",f[k].attrs['axesn']
            print " Transmitting antenna position  : ",f[k].attrs['pant']
            print " Transmitting antenna orientation  : ",f[k].attrs['vant']
            print " Group of calibration ",f[k].attrs['gcal']
            print " Calibration Index in calibration group ",f[k].attrs['ical']
                

    def get_dcal(self,gcal=1,ical=None):
        """ get calibration dictionnary

        Parameters
        ----------

        gcal : calibration group
        ical : calibration index in group
            if == None all calibration are provided in the dict

        """
        self.f  = h5py.File(self.filename,'r')
        k = "cal"+str(gcal)
        # pdb.set_trace()
        dcal={}
        # dcal  = dict(zip(self.f[k].attrs.keys(),self.f[k].attrs.values()))
        if ical==None:
            for ical in self.f[k].keys():
                di = dict(zip(self.f[k][ical].attrs.keys(),self.f[k][ical].attrs.values()))
                dcal[ical]=di
        else:
            ical=str(ical)
            dcal[ical]=dict(zip(self.f[k][ical].attrs.keys(),self.f[k][ical].attrs.values()))
        self.f.close()

        return dcal

    def readcal(self,gcal=1,ical=1):
        """ read calibration files

        Parameters
        ----------

        gcal : int
            calibration group index
        ical : int
            calibration index

        """

        # calibration dictionnary
        self.dcal = self.get_dcal(gcal,ical)

        # fmin,fmax,Nf
        fminGHz = self.dcal[str(ical)]['fminghz']
        fmaxGHz = self.dcal[str(ical)]['fmaxghz']
        Nf = self.dcal[str(ical)]['nf']

        # get the mimo calibration file
        if '_filecalh5' in self.dcal[str(ical)]:
            _filecalh5 = self.dcal[str(ical)]['_filecalh5']
            # group of calibration mimo
            gcalm = self.dcal[str(ical)]['gcalm']
            filecalh5 = pyu.getlong(_filecalh5, pstruc['DIRMES'])+'.h5'
            self.fmimo  = h5py.File(filecalh5,'r')
            self.fsiso  = h5py.File(self.filename,'r')
            km = 'cal'+str(gcalm)
            ks = "cal"+str(gcal)

            Co   = np.array(self.fmimo[km][str(ical)])
            Co11 = Co[:,0,0,:]
            Cto  = Co/Co11[:,None,None,:]
            Cn11 = np.array(self.fsiso[ks][str(ical)])
            Cn   = Cn11*Cto
            self.fsiso.close()
        else:
            self.fmimo  = h5py.File(self.filename,'r')
            km = 'cal'+str(gcal)
            Cn  = np.array(self.fmimo[km][str(ical)])

        self.fmimo.close()
        self.fGHz = np.linspace(fminGHz,fmaxGHz,Nf)
        self.cal = Mchannel(x=self.fGHz,y=Cn,filename=self.filename,mes=km,calibrated=False)

    def read(self,k,ix=[0,0,0,0],calibrate=True):
        """ read measure

        Parameters
        ----------

        k : int
            index of measure group to read
        ix : [ix,iy,iz,ia] list
        calibrate : boolean

        Notes
        -----
        For the selected measurement

        + retrieve the corresponding calibration gcal/ical
        + load the corresponding calibration .cal member as a Mchannel

        """
        k = 'mes'+str(k)
        self.f = h5py.File(self.filename,'r')
        gcal = eval(self.f[k].attrs['gcal'].replace('cal',''))
        ical = eval(self.f[k].attrs['ical'])
        self.author = self.f[k].attrs['author']
        self.time = self.f[k].attrs['time']
        self.pAnt = self.f[k].attrs['pant']
        self.vAnt = self.f[k].attrs['vant']
        self.Nr = self.f[k].attrs['nr']
        self.Nt = self.f[k].attrs['nt']

        # self.power = self.f[k].attrs['power']

        self.dmes = dict(zip(self.f[k].attrs.keys(),self.f[k].attrs.values()))
        self.f.close()
        self.readcal(gcal=gcal,ical=ical)

        self.f = h5py.File(self.filename,'r')

        self.mes = Mchannel(x=self.fGHz,y=np.array(self.f[k][str(ix[0])][str(ix[1])][str(ix[2])][str(ix[3])]),filename=self.filename,mes=k,calibrated=False)
        self.ix  = ix
        self.pt  = self.f[k][str(ix[0])][str(ix[1])][str(ix[2])][str(ix[3])].attrs['pt']
        self.pa  = self.f[k][str(ix[0])][str(ix[1])][str(ix[2])][str(ix[3])].attrs['pa']
        self.pg  = self.f[k][str(ix[0])][str(ix[1])][str(ix[2])][str(ix[3])].attrs['pg']
        if calibrate:
            self.caluncal()
    
    def extract(self,lx='[:]',ly='[:]'):
        """ extract channel matrix from h5file

        lx : string 
            frequency string extraction 
        ly : string 
            nm,nr,nt string extraction 

        """

        # paste ix and iy 
        lystart = re.sub(']$','',ly)
        lxend = re.sub('^\[','',lx)
       
        ly = lystart +','+ lxend

        if ly == '[:,:]':
            return(self.mes)
        else:
           
            x = eval('self.mes.x'+lx)
           
            if x.ndim==0:
                x = np.array([x])
            y = pyu.npextract(self.mes.y,ly)
        

            M = Mchannel(x=x,y=y,calibrated=self.mes.calibrated)
            return(M) 

    def caluncal(self):
        """ calibrate or uncalibrate the current loaded measurement

        """
        if 'mes' in self.__dict__:
            if self.mes.calibrated==False:
                self.mes.y = self.mes.y/np.mean(self.cal.y,axis=0)
                self.mes.calibrated=True
            else:
                self.mes.y = self.mes.y*np.mean(self.cal.y,axis=0)
                self.mes.calibrated=False
        else:
            print "read data first"



    def open(self,mode='r'):
        """

        Parameters
        ----------

        mode : string

        """
        # ipdb.set_trace()
        filename = pyu.getlong(self._filename,pstruc['DIRMES'])
        self.f  = h5py.File(filename,mode)

    def close(self):
        """ close h5 file
        """
        self.f.close()

    def saveini(self,ical=1,_fileini='vna_config.ini'):
        """ save calibration parameters in .ini file

        Parameters
        ----------

        _fileini  : string
            calibration ini file
        ical : int
            calibration number
        """

        dcal = self.dcal[str(ical)]
        config = ConfigParser.ConfigParser()

        # stimulus section
        config.add_section("stimulus")
        config.set("stimulus",'fminghz',dcal['fminghz'])
        config.set("stimulus",'fmaxghz',dcal['fmaxghz'])
        config.set("stimulus",'nf',dcal['nf'])
        config.set("stimulus",'power',dcal['power'])

        # response section
        config.add_section("response")
        config.set("response",'param',dcal['param'])
        config.set("response",'average','on')
        config.set("response",'navrg',dcal['navrg'])
        config.set("response",'ifbhz',dcal['ifbhz'])
        config.set("response",'win',1)

        fileini = pyu.getlong(_fileini,pstruc['DIRMES'])
        fd = open(fileini,"w")
        config.write(fd)
        fd.close()

    def aggregate(self,lmes=[],lix=[],lx='[:]',ly='[:]',axis=2,calibrate=False):
        """

        Parameters
        ----------

        lmes : list of int 
            list of of group of measure to aggregate
        lix : list of list 
            for each measure the list of selected scanner axes (x,y,z,a)
        lx : string 
            frequency extraction string 
        ly : string 
            MIMO channel extraction string 
        axis : int 
            axis of concatenation 

        Returns
        -------

        MS : Mchannel


        """
        assert (len(lmes)==len(lix))

        for k,m in enumerate(lmes):
            self.read(m,ix=lix[k],calibrate=calibrate)
            
            M = self.extract(lx=lx,ly=ly) # Nm x Nt x Nr x Nf 
            try:
                y = np.concatenate((y,M.y),axis=axis)
            except:
                y = M.y 
            MS = Mchannel(x=M.x,y=y,calibrated=calibrate)
        return(MS)

    def magre(self, ipos = 0, iNr = 0, npos = 5, loop = True):
        """ enable to aggregate the channel matrices

        Parameters
        ----------

        ipos : int
            number of the ith position

        iNr  : int
            number of the receiver antenna. Note that each of the number of the antenna 
            can be see as a user

        npos : int 
            number of spatial position of the scanner 

        loop : boolean 
            if True 

        """
        
        if loop:
            for pos in range(npos):
                # Mes 1 : h1 u1 
                self.read(1,ix=[pos,0,0,0])
                H11=self.mes.y
                # Mes 2 : h2 u1 
                self.read(2,ix=[pos,0,0,0])
                H21=self.mes.y
                # Mes 3 : h3 u1 
                self.read(3,ix=[pos,0,0,0,0])
                H31=self.mes.y
                # Mes 4 : h4 u1 
                self.read(4,ix=[pos,0,0,0,0])
                H41=self.mes.y

                # Mes 5 : h1 u2 
                self.read(5,ix=[pos,0,0,0,0])
                H12=self.mes.y
                # Mes 6 : h2 u2 
                self.read(6,ix=[pos,0,0,0,0])
                H22=self.mes.y
                # Mes 7 : h3 u2 
                self.read(7,ix=[pos,0,0,0,0])
                H32=self.mes.y
                # Mes 8 : h4 u2 
                self.read(8,ix=[pos,0,0,0,0])
                H42=self.mes.y

                # Mes 9 : h1 u3 
                self.read(9,ix=[pos,0,0,0,0])
                H13=self.mes.y
                # Mes 10 : h2 u3 
                self.read(10,ix=[pos,0,0,0,0])
                H23=self.mes.y
                # Mes 11 : h3 u3 
                self.read(11,ix=[pos,0,0,0,0])
                H33=self.mes.y
                # Mes 12 : h4 u3 
                self.read(12,ix=[pos,0,0,0,0])
                H43=self.mes.y # (1, Nr, Nt, Nf)
                # fGHz = self.mes.x
                u1 = np.concatenate((H11[:,:,:,:],H21[:,:,:,:],H31[:,:,:,:],H41[:,:,:,:]),axis=2) # (1, Nr, Ntagr, Nf)
                u2 = np.concatenate((H12[:,:,:,:],H22[:,:,:,:],H32[:,:,:,:],H42[:,:,:,:]),axis=2)
                u3 = np.concatenate((H13[:,:,:,:],H23[:,:,:,:],H33[:,:,:,:],H43[:,:,:,:]),axis=2)
                try:
                    U1 = np.concatenate((U1,u1),axis=0) # (npos,Nr,Ntagr,Nf)
                    U2 = np.concatenate((U2,u2),axis=0)
                    U3 = np.concatenate((U3,u3),axis=0)
                except:
                    U1 = u1
                    U2 = u2
                    U3 = u3

            return(U1,U2,U3)


        # first virtualization of Tx
        for i in range(self.imes):
            i1 = 1 + i 
            self.read(i1,ix=[ipos,0,0,0,0])
            h = self.mes.y[0,iNr,:,:] # (8, 801)
            # ipdb.set_trace()
            try:
                h1 = np.concatenate((h1,h),axis=0) # Nt*imes x Nf
            except:
                h1 = h
        # return h1

        # second virtualization of Tx
        for i in range(self.imes):
            i2 = 5 + i 
            self.read(i2,ix=[ipos,0,0,0,0])
            h = self.mes.y[0,iNr,:,:] # (8, 801)
            try:
                h2 = np.concatenate((h2,h),axis=0) # Nt*imes x Nf
            except:
                h2 = h
        # return h2
                
        # third virtualization of Tx
        for i in range(self.imes):
            i3 = 9 + i 
            self.read(i3,ix=[ipos,0,0,0,0])
            h = self.mes.y[0,iNr,:,:] # (8, 801)
            try:
                h3 = np.concatenate((h3,h),axis=0) # Nt*imes x Nf
            except:
                h3 = h
        # return h3

        Hagr = np.concatenate((h1[None,:,:],h2[None,:,:],h3[None,:,:]),axis=0) # (3,Nt*imes,Nf)

        return(Hagr)

    def eigenvalues(self,h = np.empty(((5,4,32,801)),dtype=complex)):
        """
        Examples
        --------

        >>> U1,U2,U3 = M.magre(loop=True) # 5 x 4 x 32 x Nf
        >>> S1 = M.eigenvalues(h=U1)      # 5 x 801 x 4
        >>> S2 = M.eigenvalues(h=U2) 
        >>> S3 = M.eigenvalues(h=U3)

        """
        
        u1 = np.swapaxes(h,0,2)                   # Ntagr x Nr x npos x Nf
        h = u1                                    # Ntagr x Nr x npos x Nf
        hT = np.conj(np.swapaxes(h,0,1))          # Nr x Ntagr x npos x Nf
        hhT = np.einsum('ijlm,kilm->jklm',h,hT)   # Nr x Nr x npos x Nf
        hhT1  = hhT.swapaxes(0,2)                 # npos x Nr x Nr x Nf
        hhTb  = hhT1.swapaxes(1,3)                # npos x Nf x Nr x Nr
        U,S,V = svd(hhTb)                         # npos x Nf x Nr
        return(S)
         
    def singvalues(self,h = np.empty(((5,4,32,801)),dtype=complex)):
        """
        Examples
        --------

        >>> U1,U2,U3 = M.magre(loop=True) # 5 x 4 x 32 x Nf
        >>> S1 = M.eigenvalues(h=U1)      # 5 x 801 x 4
        >>> S2 = M.eigenvalues(h=U2) 
        >>> S3 = M.eigenvalues(h=U3)

        """
        
        
        h13 = np.swapaxes(h,1,3)           # npos x Nf x Ntagr x Nr
        h23 = np.swapaxes(h13,2,3)         # npos x Nf x Nr x Ntagr
        U,S,V= svd(h23)                    # npos x Nf x Nr

        return(S)
    
    def chancor(self,h = np.empty((2,32),dtype=complex)):
        """ calculate the channel correlation

        Examples
        --------
        >>> M = Mesh5('mesMIMO')
        >>> Hmes = M.magre(loop=False)
        >>> hiid = M.chaniid()
        >>> yiid,delta2iid = M.chancor(Hf=hiid)
        >>> hmeas = np.sum(Hmes[0:2,:,:],axis=2) # sum over frequency and u1 and u2 are chosen
        >>> ymeas,delta2 = M.chancor(Hf=hmeas)

        """

        # choose u1 and u2 : Hmes[0:2,:,:]  (2, Ntagr, Nf)
        # choose u1 and u3 : Hmes[::2,:,:]  (2, Ntagr, Nf)
        # choose u2 and u3 : Hmes[1:,:,:]   (2, Ntagr, Nf) 
        
        Mt = self.Nt*self.imes
        y = np.empty((Mt),dtype=complex)
        delta2 = np.empty((Mt),dtype=complex)

        for im in range(Mt):
            H  = h[:,0:im]        
            Hh = np.conj(H.T)                
            G  = np.dot(H,Hh)                 
            Gn = G/(np.trace(G)/2.)          
            # channel corellation
            d_2   = np.abs(Gn[0][1]**2)
            denum = np.prod(np.diag(Gn))
            yk = d_2/denum
            y[im]=yk
            delta2[im]=y[im]*denum

        return(y,delta2)               # (Mt,)

    def chaniid(self):
        """
 
        Examples
        --------

        >>> M = Mesh5('mesMIMO')
        >>> hiid = M.chaniid()
        """
        K = 2
        Mt = self.Nt * self.imes


        for im in range(Mt):
            im = im + 1
            Hiid = np.empty((K*1,im),dtype=complex)
            for k in range(K):
                Re = np.random.randn(1,im)      # K x Mt   
                Im = np.random.randn(1,im)      # K x Mt
                Hk = Re +1j*Im                # K x Mt
                Hiid[k,:] = Hk
        return(Hiid)


    
    def irplot(self,y=np.empty((5,4,32,801),dtype=complex),npts = 100000, Nz = 0, beta = 8.6):
        """ plot the impulse response of the channel U (contained the users).

        U : 3 x Ntagr x Nf


        beta : kaiser window shape 
            0   : rectangular 
            5   : similar to a Hamming
            6   : similar to a Hanning
            8.6 : similar to a blackman

        Examples
        --------

        >>> M = Mesh5('mesMIMO')
        >>> U1,U2,U3 = M.magre(loop=True)
        >>> M.irplot(y=U1)

        """

        U = y
        K = U.shape[1]
        fGHz=np.linspace(1.8,2.2,801)
        fmin = fGHz[0]
        fmax = fGHz[-1]
        Nf = len(fGHz)
        df = (fmax-fmin)/(Nf-1)
        Mt = self.Nt*self.imes   
        win = np.kaiser(Nf,beta) 
        fmaxbis = fmax+Nz*df
        dfbis = (fmaxbis-fmin)/(Nf+Nz-1)
        Tobs = 1/dfbis 
        tau  = np.linspace(-Tobs/2,Tobs/2,Nf+Nz)
        for i in range(5):
            for r in range(K):
                for t in range(Mt):
                    irU = np.fft.fft(np.conj(np.hstack((U[i,r,t,:]*win,np.zeros(Nz)))),axis=0)
                    IRU =fftshift(irU)
                    
            plt.plot(tau,10*np.log10(np.abs(IRU)),linewidth=1)
            plt.title('Impulse Response while axis X moving along 70cm')
            plt.xlabel(r'Delay $\tau$(ns)')
            plt.ylabel('Amplitude (dB)')
            plt.xlim(0,500)
            plt.grid()
        
    def su_lund(self,g,rho):
        """ handles the performance in terms of SU 

        if g --> 1 means decorellation between channels
        """   
        Mt = self.Nt*self.imes
        C_su = np.empty(((Mt)),dtype=complex)
        for im in range(Mt):
            C_su[im]  = np.log(1 + rho*(1 + g))/np.log(2) # shape : Nt
            
        return(C_su)


    def zf_lund(self,g,rho,ipos,iNr,delta2,Ntrial=500):
        """ handles the performance in terms of ZF
        if g --> 1 means decorellation between channels

        Examples
        --------

        >>> M = Mesh5('mesMIMO')
        >>> Hmes = M.magre(loop=False)
        >>> hmeas = Hmes[0:2,:,:] # sum over frequency and u1 and u2 are chosen
        >>> y,delta2 = M.chancor(h=np.sum(Hmes[0:2,:,:],axis=2))
        >>> czf = M.zf_lund(g=0.3,rho=10.0,ipos = 0,iNr = 0,delta2=delta2,h=hmeas)
        """   
        
        K = 2
        Mt = self.Nt*self.imes

        rho2     = rho**2
        g2       = g**2
        denum    = 1 - g2
        treshold = 1 - g2 - (2*g/rho)
        C_zf     = np.empty((Mt),dtype=complex)

        
        for im in range(Mt):
            t = 0
            for i in range(Ntrial):
                d2       = delta2
                if d2[im] <= treshold:
                    num    = (2 + rho * (1 - g2 - d2[im]))**2
                    denum  = 4 * (1 - g2)
                    c_zf   = np.log(num / denum) / np.log(2)
                else:
                    numerat   = rho*(1 - g2 - d2[im])
                    denumerat = 1 - g
                    c_zf      = np.log(1 + (numerat/denumerat))/np.log(2)

                t = t + c_zf
        
            C_zf[im]  = t / Ntrial                             # shape : Nt
       
        return(C_zf)


    def dpc_lund(self,g,rho,ipos,iNr,delta2):
        """ handles the performance in terms of DPC

        if g --> 1 means decorellation between channels
        """   
        
        K = 2
        Mt = self.Nt*self.imes

        rho2     = rho**2
        g2       = g**2
        denum    = 1 - g2
        treshold = 1 - g2 - (2*g/rho)
        C_dpc    = np.empty((Mt),dtype=complex)
        

        for im in range(Mt):
            d2       = delta2
        
            if d2[im] <= treshold:
                num   = rho2 * ((1 - g2 - d2[im])**2) + (4 * g2)
                denum = 4 * (1 - g2 - d2[im])
                c_dpc           = np.log(1 + rho + (num / denum)) / np.log(2)
            else:
                numerat   = rho*(1 - g2 - d2[im])
                denumerat = 1 - g
                c_dpc     = np.log(1 + rho*(1 + g))/np.log(2)
            
            C_dpc[im] = c_dpc                             # shape : Nt
        
        return(C_dpc)


    def mmse_lund(self,g,rho,eps=1e-16):
        """ handles the performance in terms of ZF, DPC, MMSE and MF
        
        Parameters
        ----------
        eps :  is  the  tolerance  level (float)

        if g --> 1 means decorellation between channels
        """   
        
        K = 2
        Mt = 32

        rho2     = rho**2
        g2       = g**2
        denum    = 1 - g2
        treshold = 1 - g2 - (2*g/rho)
        C_mmse    = np.empty((Mt))
        delta2   = np.empty((Mt))
        
        Hiid = self.iidchan()
        Hmes = self.magre()[:,:,10] # we choose two users : (2, 32, 801)
        y,delta2 = self.chancor(Hf)

        while(P1 - P2 > eps) :

            for im in range(Mt):
                # Hf = Hmes[:,:,10] # for one specific frequency
                Hf       = Hmes
                d2       = delta2

                alpha  = K / rho
                alpha2 = alpha**2 

                
                nter1 = 2 * P1 * g * (alpha2 - 1 + g2 + d2[im])
                dter1 = (((1 + g + alpha) * (1 - g - alpha)) - d2[im])**2
                
                nter2 = ((1 + g + alpha)**2) * (1 - g) - (1 + g +  2*alpha) * d2[im]
                dter2 = (((1 + g + alpha) * (1 - g - alpha)) - d2[im])**2

                ter1 =  nter1 / dter2 
                ter2 =  nter2 / dter2

                normfac = ter1 + ter2

                num1 = rho * P1 * ( ((1 + g)*(1 - g + alpha) - d2[im])**2 )
                denum1 = (rho * P2 * alpha2 * d2[im]) + \
                        (normfac * ((((1 + g + alpha) * (1 - g + alpha)) - d2[im])**2))

                num2 = rho * P2 * ( ((1 - g)*(1 + g + alpha) - d2[im])**2 )
                denum2 = (rho * P1 * alpha2 * d2[im]) + \
                        (normfac * ((((1 + g + alpha) * (1 - g + alpha)) - d2[im])**2))

                sinr1 = num1 / denum1
                sinr2 = num2 / denum2



                # C_mmse[im] = 
        
        return(C_mmse)

    # def montecarlo(self,Ntrial=100, ym = np.empty((32),dtype=complex)):
    #     """
    #     """

    #     ty = 0
        
    #     for k in range(Ntrial): # Monte carlo
    #         ty  = ty + ym
    #     ymont  = ty / Ntrial

    #     return(ymont)

    # def plot_perf(self, Ntrial = 100, g = 0.2, rho = 5.0, y = np.empty(((32)),dtype=complex)):
    #     """ plot performances of the capacity
    #     """ 
    #     Mt = self.Nt * self.imes

    #     ty = np.zeros((Ntrial,Mt))
    #     # c = np.zeros((Mt))
    #     H3 = self.magre(loop=False)
    #     for k in range(Ntrial):               
    #         y11,delta11 = self.chancormeas(yc = np.mean(H3[0:2,:,:],axis=2))
    #         ty11  = ty11 + y11

    #     c  = ty11 / Ntrial
    #     plt.plot(np.arange(32),c)
    #     plt.title('performances of the sum rates over the corellation : g' + 
    #               ' = ' + str(g) + ' , ' + r'$\rho$' + ' = ' + str(rho))
    #     plt.xlabel('Number of antennas')
    #     plt.ylabel('sum rate [bits/s/Hz]')
    #     plt.legend(loc='best')
    #     plt.legend()
    #     plt.grid()

    # def plot_chor(self):
    #     """ plot the channel correlation
    #     """

    #     Mt = self.Nt * self.imes
    #     tymes  = np.zeros((801,Mt))
    #     Hiid = self.iidchan()
    #     Hmes = self.magre()[0:-1,:,:] # we choose two users : (2, 32, 801)

    #     for k in range(801): # not good do the monte carlo an another way
    #         Hf = Hmes[:,:,k]
    #         y,delta2 = self.chancor(Hf)
    #         tymes[k,:]=y

    #     ty_mean = np.mean(Hiid,axis=0)
    #     tymes_mean = np.mean(tymes,axis=0)

    #     plt.plot(np.arange(Mt),ty_mean,'b',label='IID Gaussian Channel',linewidth=3)
    #     plt.plot(np.arange(Mt),tymes_mean,'r',label='Measured Channel',linewidth=3)

        
    #     plt.xlabel('Number of base station antennas')
    #     plt.ylabel('Channel correlation')
    #     plt.title('Behavior of the channel correlation over base station antennas')
    #     plt.legend()
    #     plt.grid()

    def plot(self,cmd='mes'):
        """show calibration from vna

        Parameters
        ----------
        mes : string
        lg  : list
        cmd : string
            mes | cal | ir

        """

        #self.read(mes,lg)
        plt.ion()

        if cmd == 'mes':
            if self.mes.calibrated:
                self.mes.plot()
                plt.suptitle("Measurement Calibrated Channel")
            else:
                plt.suptitle("Measurement Channel Not Calibrated")

        if cmd == 'cal':
            self.cal.plot()
            plt.suptitle("Calibration transfer function")

        if cmd == 'ir':
            cir = self.mes.ift(ffts=1)
            cir.plot()
            plt.suptitle("Impulse Response")
        plt.tight_layout()
        plt.show()


    def eig_val(self):
        """ calculate the eigen value of the matrix HdH.
            
        Returns
        -------

        HdH : U^{\dagger} L U : Hermitian transfer matrix : npos x nt x nt x nf
        Ud  : Unitary tensor                              : npos x nf x nt x nt
        L   : Lambda eigen values                         : npos x nf x nt
        U   : Unitary tensor                              : npos x nf x nt x nt
        
        """

        
        H   = self.matrix() #H  : npos x nr x nt x nf       
        Hd  = np.conj(H.swapaxes(1,2)) #Hd : npos x nt x nr x nf
        HdH = np.einsum('ijkm,iklm->ijlm',Hd,H) #HdH : npos x nt x nt x nf
        HdH  = HdH.swapaxes(1,3) #HdH : npos x nt x nt x nf
        #Ud   : npos x nf x nt x nt
        #L   : npos x nf x nt
        #U   : npos x nf x nt x nt
        Ud,L,U  = la.svd(HdH)
        return (HdH,Ud,L,U)

    def sing_val(self):
        """ calculate the singular values of the matrix H.
            

        Returns
        -------

        H  : U D U^{\dagger} Hermitian transfer matrix : npos x nr x nt x nf
        U  : Unitary tensor                            : npos x nf x nt x nt
        D  : Singular values of the matrix H           : npos x nf x nr
        Vd : Unitary tensor                            : npos x nf x nr x nr


        """
        H   = self.matrix()  # H.shape : npos x nr x nt x nf     
        Hswp = H.swapaxes(1,3)
        #U   : npos x nf x nt x nt
        #D   : npos x nf x nr
        #Vd  : npos x nf x nr x nr
        U,D,Vd  = la.svd(Hswp)
        return (H,U,D,Vd)

    def normalize(self):
        """ Normalization of channel matrix H

        """
        
        H = self.matrix() #Hnorm.shape : npos x nr x nt x nf
        
        HdH,Ud,L,U = self.eig_val() #HdH : npos x nt x nt x nf
        
        HdHsw = HdH.swapaxes(1,3) #HdHsw : npos x nf x nt x nt
               
        rg = np.real(np.sqrt(np.sum(L,axis=2)/(self.Nt*self.Nr))) #rg2.shape : npos x nf
              
        Hnorm = H / rg[:,None,None,:] # Hnorm2.shape : npos x nr x nt x nf

        return(H,Hnorm,rg)


    def CBcapacity(self,Pt=np.array([1e-3]),Tp=273,h = np.empty(((5,4,32,801)),dtype=complex)):
        """ BLAST algorithm
        calculates the deterministic single user MIMO channel capacity

        Parameters
        ----------

        Pt : np.array (,NPt)
            the total power is assumed uniformaly distributed over the whole bandwidth
        Tp : Receiver Temperature (K)

        Returns
        -------

        C   : spectral efficiency (bit/s/Hz)
            np.array (Nf,NPt)
        rho : SNR
            np.array (Nf,Nt,NPt)

            log_2(det(I+(Et/(N0Nt))HH^{H})
        N0 : spectral noise density 

        """
        
        fGHz=np.linspace(1.8,2.2,801)
        fmin = fGHz[0]
        fmax = fGHz[-1]
        Nf = len(fGHz)
        BGHz  = fGHz[-1]-fGHz[0]
        dfGHz = fGHz[1]-fGHz[0]

        U1 = h
        S = self.eigenvalues(h=U1) # npos x Nf x Nr
        
        if type(Pt)==float:
            Pt=np.array([Pt])

        # White Noise definition
        kB = 1.03806488e-23
        # N0 ~ J ~ W/Hz ~ W.s
        N0 = kB*Tp 

        #Pt.shape = (power,)
        Ps  = Pt/(self.Nt) #Ps.shape = (power,)
        
        Pb  = N0*BGHz*1e9 # Watts ; Pb.shape = (power,)

        rho  = (Ps[None,None,None,:]/Pb)*S[:,:,:,None] # rho.shape : npos x Nf x Nr x power

        #We sum along the Nr
        CB  = dfGHz*np.sum(np.log(1+rho)/np.log(2),axis=2) # CB.shape : npos x nf x power

        return(CB)

    def WFcapacity(self,Pt=np.array([1e-3]),Tp=273,h = np.empty(((5,4,32,801)),dtype=complex)):
        """ waterfilling algorithm
            calculates the deterministic single user MIMO channel capacity

            waterfilling algorithm : 
            
            $P_i$ = ($\mu$ - (1/$\sigma$^2))^+  ; i = 1,2,...,r and r = min(Nr,Nt)
            $a$^+ is defined as max(a,0) and $\mu$ is chosen such as sum(Pi) = Pt

            The water level ($\mu$) that touch the worst channel is the hihest one.
            Pt is the Available power.
            Ps is the powerin each channel.
            
            step 1 : calculates the water level that touch the worst channel and then transmits
                     zero power in this worst channel.
            
            step 2 : calculates the power (Ps) in each channel for this channel :
                     if the sum of all these power in Ps < Pt:
                        Divide the remaining power equally among all the channels (in order to 
                        increase $\mu$).
                     if the sum of all of these powers in Ps > Pt:
                        Remove the worst channel and repeat the process.

            NB : at low SNR, the waterfilling algorithm allocates all power to the strongest of the r higest $\lambda$
                 at high SNR, the waterfilling algorithm allocates approximately equal power over the eigenvalues of HHh.

        Parameters
        ----------

        Pt :  the total power to be distributed over the different spatial
            channels using water filling
        Tp : Receiver Noise Temperature (K)

        Returns
        -------

        C : capacity (bit/s)        : npos x nf x power 

        rho : SNR (in linear scale) : npos x nf x nt x power

              formulas log_2(det(It + HH^{H})

        """

        npos = h.shape[0]
        Nr = h.shape[1]
        fGHz=np.linspace(1.8,2.2,801)
        Nf = len(fGHz)
        BGHz  = fGHz[-1]-fGHz[0]
        dfGHz = fGHz[1]-fGHz[0]

        
        U1 = h
        S = self.eigenvalues(h=U1) # npos x Nf x Nr

        # White Noise definition
        
        kB = 1.03806488e-23 #Boltzman constant
        N0 = kB*Tp #N0 ~ J ~ W/Hz ~ W.s

        #
        #Iterative implementation of Water Filling algorithm
        #

        

        pb = N0*dfGHz*1e9*np.ones((npos,Nf,Nr)) # npos x nf x nr
        pt = Pt[None,None,None,:]/((Nf-1)*Nr)   # power x power x power x power

        mu = pt # power x power x power x power
        Q0 = np.maximum(0,mu-pb[:,:,:,None] / S[:,:,:,None]) # npos x Nf x Nr x power
        u  = np.where(Q0>0)[0]
        Peff = np.sum(np.sum(Q0,axis=1),axis=1) #Peff.shape : npos x power
        deltamu = pt

        #while (np.abs(Peff-Pt)>1e-16).any():
        while (np.abs(Peff-Pt)>1e-8).any():
            mu = mu + deltamu
            x = pb[:,:,:,None]/S[:,:,:,None]        # npos x nf x nt x power
            Q0 = np.maximum(0,mu-x)                 # npos x nf x nr x power
            Peff = np.sum(np.sum(Q0,axis=1),axis=1) # npos x power
            usup = np.where(Peff>Pt)[0]
            mu[:,:,:,usup] = mu[:,:,:,usup] - deltamu[:,:,:,usup]
            deltamu[:,:,:,usup] = deltamu[:,:,:,usup]/2.
        # ipdb.set_trace()
        Qn  = Q0/pb[:,:,:,None]
        rho = Qn*S[:,:,:,None] # npos x nf x nr x power
        Cwf  = dfGHz*np.sum(np.log(1+rho)/np.log(2),axis=2) # npos x nf x power

        return(Cwf)



    def zf_precoding(self,kusers=85):
        """ zero forcing channel inversions
        """
        Qn,rho,Cwf = self.WFcapacity()
        fGHz,Nf,BGHz,dfGHz = self.freq()
        
        Hs = self.matrix()
        H  = Hs.swapaxes(1,3) # H : npos x nf x nt x nr
        Hh = np.conj(H.swapaxes(2,3)) # Hh : npos x nf x nr x nt
        HHh = np.einsum('ijkm,ijml->ijkl',H,Hh) # HHh : npos x nf x nt x nt
        iHHh = np.linalg.inv(HHh) # iHHh : npos x nf x nt x nt
        
        # Design of the precoding matrix W
        W  = np.einsum('ijkl,ijlm->ijkl',Hh,iHHh)  # W : npos x nf x nr x nt
        W1 = W.swapaxes(2,3) # W1 : npos x nf x nt x nr

        # print "H.shape    :",H.shape
        # print "Hh.shape   :",Hh.shape
        # print "HHh.shape  :",HHh.shape
        # print "iHHh.shape :",iHHh.shape
        # print "W.shape    :",W.shape    

        hk = np.sum(H,axis=0)  # hk : nf x nt x nr
        
        wk = np.sum(W1,axis=0) # hk : nf x nt x nr
        
        HW = np.abs(hk*wk)**2

        rho  = Qn/kusers

        Czf  = dfGHz*np.sum(np.log(1+(rho*HW)/np.log(2)),axis=0)

        #print "W1.shape   :",W1.shape
        #print "rho.shape  :",rho.shape
        #print "Czf.shape  :",Czf.shape
        
        return(W1,rho,Czf)
        


if __name__=='__main__':
    doctest.testmod()
    M = Mesh5('mes_4_8')
    H  = M.matrix()
    # fGHz,Nf,BGHz,dfGHz =M.freq()
    # rhoB,CB = M.Bcapacity(Pt = np.logspace(-9,-3,100))
    # rhowf,Cwf = M.WFcapacity(Pt = np.logspace(-9,-3,100))

    # Cwf11 = np.sum(Cwf[0,:,:],axis=0)
    # CB11 = np.sum(CB[0,:,:],axis=0)
    # Cwf12 = np.sum(Cwf[84,:,:],axis=0)
    # CB12 = np.sum(CB[84,:,:],axis=0)
    # Pt = np.logspace(-9,-3,100)
    # plt.ion()
    # plt.figure(figsize=(10,10))
    # plt.subplot(211)
    # plt.semilogx(Pt,CB11,label='BLAST_npos0')
    # plt.semilogx(Pt,Cwf11,label='WF_npos0')
    # plt.legend(loc='best')
    # plt.subplot(212)
    # plt.semilogx(Pt,CB12,label='BLAST_npos84')
    # plt.semilogx(Pt,Cwf12,label='WF_npos84')
    # plt.legend(loc='best')
    # plt.show()

    # npos = 85
    # for n in range(npos):
    #     Pt = np.logspace(-9,-3,100)
    #     Cwf1 = np.sum(Cwf[n,:,:],axis=0)
    #     plt.ion()
    #     plt.subplot(211)
    #     plt.semilogx(Pt,Cwf1)
    #     plt.subplot(212)
    #     CB1 = np.sum(CB[n,:,:],axis=0)
    #     plt.semilogx(Pt,CB1)
    # plt.show()
